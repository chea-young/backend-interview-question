# Backend-Interview-Question

## html내 마크다운 문법 사용법

html태그 밑에 빈 라인을 추가해야 마크다운이 적용된다.

예시)

<details><summary style="color:skyblue">CLICK ME</summary>
<p>
  
#### yes, even hidden code blocks!

## hi

**강조**

- 1
- 2
- 3

```python
print("hello world!")
```

</p>
</details>

## Table Of Contents

- [이 저장소를 잘 사용하기 위한 팁](#이-저장소를-잘-사용하기-위한-팁)
- [CS 관련 지식](#CS-관련-지식)
- [언어 관련](#언어-관련)
- [기타](#기타)
- [면접 꿀팁](#면접-꿀팁)


## 이 저장소를 잘 사용하기 위한 팁

문제를 보고 음성메모로 답을 해봅시다. 그리고 음성메모를 들으면서 자신이 알고있는 것이 잘 전달되는지 확인합시다.

문제에 대한 내용에 대한 답변은 상당히 간추린 내용이기 때문에, 누락되거나 불필요하다 판단하여 덜어낸 부분이 존재할 수 있습니다. 그리고 정답이라고 할만한 것이 존재하지 않는 문제도 존재하기 때문에 '이 사람은 이렇게 답변했겠구나' 정도로 받아들이시는 것을 권장합니다.

예제 답변 그대로 답변하면 좋겠지만, 최대한 짧고 간결하게 대답해야만 면접자 입장에서 좀 더 유리합니다. 궁금하면 면접관님께서 꼬리질문으로 깊이있게 물어보실 것입니다.

추가로 아래 내용에 보충을 하고싶다면, issue 혹은 PR로 기여를 해주세요. 저도 초보 개발자이기 때문에 틀리거나, 잘못된 내용이 있을 수 있습니다.

모의 면접을 도와줄 지인이 있다면 모의면접을 부탁해서 실제 면접처럼 수행하면 더욱 실전에서 도움이 될 것 같습니다.

이 주제들을 가지고 학습을 하는 것도 도움이 많이 될 것입니다.

## CS 관련 지식

### 프로그래밍 공통

<details>
  <summary> 프레임워크와 라이브러리 차이</summary>
  </br>
  둘의 차이는 실행 흐름에 대한 제어 권한이 어디에 있는지에 따라 달라집니다.
- 프레임워크: 전체적인 흐름을 자체적으로 제어한다
- 라이브러리: 사용자가 흐름에 대한 제어를 하며 필요한 상황에 가져다가 쓸 수 있다. 
- 
</details>

<details>
  <summary>동기와 비동기의 차이 </summary>
  </br>
- 동기: 요청을 보내고 실행이 끝나면 다음 동작을 처리하는 방식입니다. 여러가지 요청을 동시에 처리할 수 없어 효율이 떨어진다.
- 비동기 : 요청을 보내고 해당 동작의 처리 여부와 상관없이 다음 요청이 동작하는 방식입니다. 작업이 완료되는 시간을 기다릴 필요가 없기 때문에 자원을 효율적으로 사용할 수 있습니다. 하지만 작업이 완료되 ㄴ결과를 제어하기 어렵습니다.

</details>

</details>
<details>
  <summary>SQL Injection </summary>
  </br>
- SQL Injection이란 공격자가 악의적인 의도를 갖는 구문을 삽입하여 공격자가 원하는 SQL을 실행하도록 하는 웹해킹기법입니다.

</details>

</details>
<details>
  <summary>메세지 큐(Message Queue)란?</summary>
  </br>
- Queue 자료구조를 이용하여 데이터(메세지)를 관리하는 시스템으로, 비동기 통신 프로토콜을 제공하여 메세지를 빠르게 주고 받을 수 있게 해준다.메세지 큐에서는 Producer(생산자)가 Message를 Queue에 넣어두면, Consumer가 Message를 가져와 처리하게 됩니다.

</details>

</details>
<details>
  <summary>[ Docker(도커) ]</summary>
  </br>
- Docker는 컨테이너 기반의 가상화 기술입니다.
- 장점: 쉽고 빠르게 실행 환경 구축 가능, 하드웨어 자원 절감, Docker Hub와 같은 공유 환경을 제공합니다.

</details>

</details>
<details>
  <summary> TDD(Test-Driven Development)</summary>
  </br>
TDD(Test-Driven Development)는 매우 짧은 개발 사이클의 반복에 의존하는 개발 프로세스로, 개발자는 우선 요구되는 기능에 대한 테스트케이스를 작성하고, 그에 맞는 코드를 작성하여 테스트를 통과한 후에 상황에 맞게 리팩토링하는 테스트 주도 개발 방식을 의미합니다.

</details>
</details>
<details>
  <summary>DDD(Domain-Driven Design) </summary>
  </br>
실세계에서 사건의 발생하는 집합인 Domain(도메인)을 중심으로 설계하는 방법입니다. 이러한 도메인들이 서로 상호작용하며 설계하는 것이 도메인 주도 설계입니다. 

</details>

### 네트워크

<details>
  <summary>웹 통신의 큰 흐름: https://www&#46;google&#46;com/ 을 접속할 때 일어나는 일</summary>
  </br>
- 브라우저에 웹 페이지 데이터가 도착하는 과정
1. 주소창에 url을 입력하고 enter를 칩니다.
2. IP 주소를 찾기 위해 캐시에서 DNS 기록을 확인합니다.
    - 만약 요청한 URL(maps.google.com)이 캐시에 없다면, ISP의 DNS 서버가 DNS 쿼리로 maps.google.com을 호스팅하는 서버의 IP 주소를 찾습니다.
3. HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성합니다.
4. HTTP 요청을 하기 위해 브라우저가 서버와 TCP 연결을 합니다.(TCP/IP handshaking)
    - TCP 연결이 됬으면 HTTP 요청을 보냅니다.
5. 서버는 HTTP 프로토콜을 활용해 HTTP 응답 메세지를 생성합니다.
6. TCP/IP 연결을 통해 요청한 컴퓨터로 전송합니다.
7. 도착한 HTTP 응답 메세지는 웹 페이지 데이터로 변환되고, 웹 브라우저에 의해 출력되어 사용자가 볼 수 있습니다.

- 웹 페이지 데이터가 변환되어 출력되는 과정
1. 해당 페이지에 존재하는 여러 자원들(text, image 등)이 보내집니다.
2. 브라우저는 해당 자원이 담긴 html과 스타일이 담긴 css를 W3C 명세에 따라 해석합니다.
3. 해석하는 역할을 하는 렌더링 엔진이 동작합니다.
    1. HTML 파싱 과정을 시작합니다. HTML 파서가 문서에 존재하는 어휘와 구문을 분석하면 DOM 트리를 구축합니다.
    2. 다음에는 CSS 파싱 과정을 시작합니다. CSS 파서가 모든 CSS 정보를 스타일 구조체로 생성합니다.
    3. 이 두가지, DOM 트리와 스타일 구조체를 연결시켜 렌더 트리를 만듭니다.
        - 렌더 트리를 통해 문서의 시각적 요소를 포함한 형태로 구성된 상태가 됩니다.
    4. 화면에 배치를 시작하고, UI 백엔드가 노드를 돌며 형상을 그립니다.
        - 빠른 브라우저 화면 표시를 위해 '배치와 그리는 과정'은 페이지 정보를 모두 받고 한꺼번에 진행되지 않음으며 자원을 전송받으면, 기다리는 동시에 일부분 먼저 진행하고 화면에 표시됩니다.
</details>

<details>
  <summary> 브라우저와 서버의 차이</summary>
  </br>
  - 브라우저는 HTTP를 요청합니다.
  - 서버는 HTTP 요청을 받아 HTML 같은 정적 컨텐츠를 제공하는 프로그램으로 HTTP 응답을 합니다. 만약 동적 컨텐츠 요청 시 웹 컨테이너로 전달하여 웹 컨테이너가 처리한 결과를 브라우저에게 전달합니다.
</details>

<details>
  <summary>WAS(Web application server)</summary>
  </br>
  - 서버 + 웹 컨테이너
    - 브라우저로부터 HTTP 요청을 받을 수 있습니다.
    - 동적 컨텐츠를 요청하면 사용자 요청에 따라 DB조회를 하거나 다양한 로직을 처리하고 클라이언트(브라우저)에게 동적 컨텐츠를 제공합니다.
    - 정적 컨텐츠를 요청하면 정적 컨텐츠를 제공합니다.
</details>

<details>
  <summary>TCP와 UDP의 차이점에 대해서 설명해보세요.</summary>
  </br>
  <p>TCP는 연결 지향형 프로토콜이고 UDP는 비연결 지향형 프로토콜 데이터를 데이터그램 단위로 전송하는 프로토콜입니다.</p>
  <p>TCP는 가상 회선을 만들어 신뢰성을 보장하도록(흐름 제어, 혼잡 제어, 오류 제어) 하는 프로토콜로 따로 신뢰성을 보장하기 위한 절차가 없는 UDP에 비해 속도가 느린편입니다.</p>
  <p>TCP는 그래서 파일전송과 같은 신뢰성이 중요한 서비스에 사용되고, UDP는 스트리밍, RTP와 같이 연속성이 더 중요한 서비스에 사용됩니다.</p>
  <p>+) 하지만 UDP도 신뢰성을 UDP자체에서 보장하지 않는 것 뿐이지, 개발자가 직접 신뢰성을 보장하도록 할 수 있습니다. 그래서 HTTP/3은 QUIC이라는 프로토콜을 기반으로 하는데, QUIC은 UDP를 기반으로 합니다. 즉, UDP 자체는 신뢰성을 보장하지 않지만, 추가적인 정의를 통해 신뢰성을 보장받을 수 있습니다.</p>
</details>

<details>
  <summary>TCP 3, 4 way handshake에 대해서 설명해보세요.</summary>
  </br>
  <p>TCP 3 way handshake는 가상회선을 수립하는 단계입니다. 클라이언트는 서버에 요청을 전송할 수 있는지, 서버는 클라이언트에게 응답을 전송할 수 있는지 확인하는 과정입니다. SYN, ACK 패킷을 주고받으며, 임의의 난수로 SYN 플래그를 전송하고, ACK 플래그에는 1을 더한값을 전송합니다. 정확한 순서는 SYN(n) -> ACK(n + 1), SYN(m) -> ACK(m + 1) 순으로 일어납니다.</p>
  <p>3번의 통신이 완료되면 연결이 성립됩니다.</p>
  - 클라이언트가 서버에게 SYN 패킷을 보냅니다. 그러면 서버는 SYN 패킷을 받게 되면 클라이언드에게 SYN+ACK 패킷을 보냅니다. 클라이언트는 패킷을 받게 되면 ACK 보내면서 소켓을 열게되고 서버도 해당 패킷을 받으면 소켓을 열어 연결하게 됩니다.
  </br>
  <p>TCP 4way handshake는 TCP연결을 해제하는 단계로, 클라이언트는 서버에게 연결해제를 통지하고 서버가 이를 확인하고 클라이언트에게 이를 받았음을 전송해주고 최종적으로 연결이 해제됩니다. 단, 서버에서 소켓이 닫혔다고 통지해도 클라이언트 측에서는 일정시간 대기하는데, 혹시나 패킷이 나중에 도착할 수 있기 때문입니다.</p>
  <p>클라이언트는 서버에게 연결을 종료한다는 FIN 플래그를 보낸다. 서버는 FIN을 받고, 확인했다는 ACK를 클라이언트에게 보낸다. (이때 모든 데이터를 보내기 위해 CLOSE_WAIT 상태가 된다) 데이터를 모두 보냈다면, 연결이 종료되었다는 FIN 플래그를 클라이언트에게 보낸다. 클라이언트는 FIN을 받고, 확인했다는 ACK를 서버에게 보낸다. (아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 TIME_WAIT을 통해 기다린다.) 서버는 ACK를 받은 이후 소켓을 닫는다 (Closed) TIME_WAIT 시간이 끝나면 클라이언트도 닫는다 (Closed) 이렇게 4번의 통신이 완료되면 연결이 해제된다.</p>
</details>

<details>
  <summary>HTTP와 HTTPS의 차이점에 대해서 설명해보세요.</summary>
  </br>
  <p>HTTP는 인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약입니다.</p>
  <p>HTTP는 따로 암호화 과정을 거치지 않기 때문에 중간에 패킷을 가로챌 수 있고, 수정할 수 있습니다. 따라서 보안이 취약해짐을 알 수 있습니다. 이를 보완하기 위해 나온 것이 HTTPS입니다. 중간에 SSL 프로토콜을 사용해 암호화 계층을 거쳐서 패킷을 암호화합니다.</p>
</details>

<details>
  <summary>HTTPS에 대해서 설명하고 SSL Handshake에 대해서 설명해보세요.</summary>
  </br>
  <p>HTTPS는 HTTP에 보안 계층을 추가한 것입니다. HTTPS는 제3자 인증, 공개키 암호화, 비밀키 암호화를 사용합니다.</p>
  <p>제3자 인증은 믿을 수 있는 인증기관에 등록된 인증서만 신뢰하는 것이고, 공개키 암호화는 비밀키를 공유하기 위해 사용합니다. 비밀키 암호화는 통신하는 데이터를 암호화하는데 사용합니다.</p>
  <p>클라이언트는 TCP 3 way handshake를 수행한 이후 Client Hello를 전송합니다. 서버는 인증서를 보냅니다.(다른 정보들도 전송하나 검색을 통해 알 수 있는 부분입니다. 대개 그 정도까지는 요구하지 않습니다.)</p>
  <p>클라이언트는 받은 인증서를 신뢰하기 위해서 등록된 인증기관인지 확인합니다. 이 인증서는 인증기관의 개인키로 암호화되어있고, 브라우저에 내장되어있는 공개키로 클라이언트는 사이트의 정보와, 서버의 공개키를 얻을 수 있습니다.</p>
  <p>서버의 공개키로 통신에 사용할 비밀키를 암호화해서 서버에 보냅니다. 서버는 이를 개인키로 확인하고 이후 통신은 공유된 비밀키로 암호화되어 통신합니다.</p>
  <p>제3자 인증: 인증서, 인증기관/공개키 암호화: 인증서, 비밀키 공유/비밀키 암호화: 통신과정</p>

</details>

<details>
  <summary>GET과 POST의 차이점에 대해서 설명해보세요.</summary>
  </br>
  <p>GET요청은 서버에 존재하는 정보를 요청합니다. 보통 데이터를 조회하기 위해 사용되는 방식으로 데이터는 헤더에 추가하여 전송합니다. URL에 데이터가 노추되기 때문에 보안적으로 중요한 데이터는 포함해서는 안됩니다. 이 때 반환되는 정보는 정보 자체가 아니라 정보의 표현입니다. 일반적으로 Request Body는 입력하지 않는 것이 일반적이며, 레거시 시스템의 경우 요청을 받아들이지 않을 수 있습니다. 캐싱을 수행하기 때문에 캐싱되지 않는 요청은 GET 요청이 맞지 않을 수 있습니다.</p>
  <p>POST요청은 서버에 정보를 생성하는 것을 요청합니다. 또한 수정을 하기 위해 사용되는 방식으로 보통 Request Body에 요청하는 데이터를 담아 전송합니다.</p>
</details>

<details>
  <summary>HTTP 메서드와 이것이 하는 역할에 대해서 설명해보세요.</summary>
  </br>
  <ul>
    <li>GET 요청은 서버에 존재하는 데이터를 요청하는 것입니다. CRUD로 따지면 R입니다.</li>
    <li>POST 요청은 서버에 데이터를 생성하는 것을 요청합니다. CRUD로 따지면 C입니다.</li>
    <li>PUT 요청은 서버에 존재하는 데이터를 수정하거나 존재하지 않으면 생성합니다. CRUD로 따지면 C,U입니다.</li>
    <li>DELETE 요청은 서버에 데이터를 제거할 것을 요청합니다. 존재하지 않아도 동일하게 동작합니다. CRUD로 따지면 D입니다.</li>
    <li>PATCH 요청은 서버에 존재하는 데이터를 일부 수정합니다. CRUD로 따지면 U입니다.</li>
  </ul>
</details>

<details>
  <summary>RESTful이란 무엇이며, 이것에 대해서 아는대로 설명해보세요.</summary>
  </br>
  <p>REST란 어떤 자원에 대해 CRUD(Create, Read, Update, Delete) 연산을 수행하기 위해 URI(Resource)로 요청을 보내는 것으로, Get, Post 등으로 Method를 사용하여 요청을 보내며, 요청을 위한 자원은 특정한 형태(Representation of Resource)으로 표현됩니다.</p>
  - 특징
    - 서버-클라이언트 구조
    - 무상태
    - 캐시 처리 가능
    - 계층화 -> 클라이언트는 rest api 서버만 호출하고 
    - 인터페이스의 일관성 -> URI로 지정한 자원에 대한 조작을 통일되고 한정적인 인터페이스로 수행
  <p>이러한 REST 기반의 API를 웹으로 구현한 것이 RESTful API</p>
  <p>REST(REpresentational State Transfer)ful API는 HTTP 통신에서 어떤 차원에 대한 CRUD 요청을 Resource와 Method로 표현하여 특정한 형태로 전달하는 방식입니다. RESTful API는 아래와 같은 것들로 구성됩니다. 자원URI, 요청 방식, 자원의 형태(json) </p>
</details>

<details>
  <summary>MSA란?</summary>
  </br>
  <p>MSA(Microservice Architecture)는 모든 시스템의 구성요소가 한 프로젝트에 통합되어 있는 Monolithic Architecture(모놀리식 아키텍쳐)의 한계점을 극복하고자 등장하게 되었습니다.</p>
  <p>MSA는 1개의 시스템을 독립접으로 배포가능한 각각의 서비스로 분할되어 있습니다..</p>
  <p>각각의 서비스는 URL이 다르기 때문에 RESTful API를 통해 데이터를 주고받으며 1개의 큰 서비스를 구성합니다. </p>
  <p>- 각 서비스가 다른 서버에 분리 배포되어있기 때문에 서버 URL이 다르기 때문에 API Gateway를 이용하여 API 서버 앞 단에서 모든 API 서버들의 End-Point를 단일화하여 묶어줍니다. 라우팅, 로드밸런싱, 인증 역할 등등 여러 역할을 수행합니다.</p>
</details>

<details>
  <summary>메모리구조</summary>
  </br>
  <p>메모리 구조는 낮은 주소 부터 코드영역, 데이터 영역, 힙 영역, 스택 영역으로 이루어져 있습니다. </p>
  <p>코드 영역: 실행할 프로그램의 코드가 저장되는 영역으로 텍스트 영역이라고도 부릅니다. 사용자가 프로그램 실행 명령을 내리면 OS가 HDD에서 실행 코드를 메모리로 올리게 되고, CPU는 코드 영역에 저장된 명령어를 하나씩 처리하게 된다.</p>
  <p>데이터 영역: 프로그램의 전역 변수(global)와 정적 변수(static)가 저장되는 영역입니다. 데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸합니다.</p>
  <p>힙 영역: 프로그래머가 직접 관리할 수 있는 메모리 영역으로 이 공간에 메모리를 할당하는 것을 동적 할당이라고 부릅니다. Java에서는 가비지 컬렉터가 자동으로 해제해줍니다. 힙 영역은 스택 영역과 달리 낮은 주소에서 높은 주소로 메모리가 할당됩니다.</p>
  <p>스택 영역: 함수의 호출과 함께 할당되며 지역 변수와 매개 변수가 저장되는 영역입니다. 스택 영역에 저장되는 함수의 호출 정보를 스택프레임이라고 합니다. 스택 영역은 함수의 호출이 완료되면 소멸합니다. 스택 영역은 높은 주소에서 낮은 주소로 메모리가 할당됩니다.</p>
</details>

<details>
  <summary>[ Parameter와 Argument의 차이 ]</summary>
  </br>
  <p>Parameter: 함수를 선언할 때 사용된 변수 </p>
  <p> Argument: 함수가 호출되었을 때 함수의 파라미터로 전달된 실제 값</p>
</details>

<details>
  <summary>CDN란?(Content Delivery Network)</summary>
  </br>
  <p>- 물리적으로 떨어져 있는 사용자에게 컨텐츠를 더 빠르게 제공하기 위해 만들어진 기술입니다. </p>
  <p>- 느린 응답속도와 다운로드 시간을 향상시키기 위해 서버를 분산시켜 캐싱해두고, 빠르게 다운받을 수 있게 합니다.</p>
  <p>CDN은 콘텐츠에 대한 요청이 발생하면 사용자와 가장 가까운 위치에 존재하는 서버로 매핑시켜, 요청된 파일의 캐싱된(사전 저장된) 버전으로 요청을 처리합니다. 서버가 파일을 찾는 데 실패하는 경우 CDN 플랫폼의 다른 서버에서 콘텐츠를 찾은 다음 엔드유저에게 응답을 전송합니다. </p>
</details>

<details>
  <summary>CORS란 무엇이며 이것에 대해서 설명해보세요.</summary>
  </br>
  <p>도메인이 다른 2개의 사이트가 자원을 공유하며 데이터를 주고 받을 때 발생하는 문제 입니다. 대부분의 브라우저에서는 이것을 차단하며, 서버측에서 헤더를 통해서 사용가능한 자원을 알려줍니다.</p>
  <p>CORS가 생기게 된 이유는 서버 내에서 요청이 허락된 도메인에만 데이터를 주기 위해서인데, 요청을 허락하기 위해서는 'Access-Control-Alow-Origin: {도메인}' 과 같은 내용을 Response의 헤더에 추가해주어야 합니다다. 만약 도메인을 *으로 설정하면 모든 도메인에 대해 요청을 허락할 수 있습니다.  </p>
    <p>Access-Control-Allow-Orgin : 요청을 보내는 페이지의 출처 [ *, 도메인 ] </p>
    <p>Access-Control-Allow-Methods : 요청을 허용하는 메소드. Default : GET, POST</p>
    <p>Access-Control-Max-Age : 클라이언트에서 preflight 요청 (서버의 응답 가능여부에 대한 확인) 결과를 저장할 시간</p>
    <p>Access-Control-Allow-Headers : 요청을 허용하는 헤더 </p>
</details>

<details>
  <summary>OSI7계층</summary>
  <p> 물리(Physical): 단지 데이터 전기적인 신호로 변환해서 주고받는 기능을 진행하는 공간입니다. (리피터, 케이블, 허브) </p>
  <p>데이터 링크(Data Link): 물리 계층으로 송수신되는 정보를 관리하여 안전하게 전달되도록 도와주는 역할을 하며 Mac 주소를 통해 통신한다. 프레임에 Mac 주소를 부여하고 에러검출, 재전송, 흐름제어를 진행한다.(브릿지, 스위치) </p>
  <p>네트워크(Network): 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능을 담당한다. 라우터를 통해 이동할 경로를 선택하여 IP 주소를 지정하고, 해당 경로에 따라 패킷을 전달해준다.(라우터, IP)</p>
  <p>전송(Transport): TCP와 UDP 프로토콜을 통해 통신을 활성화한다. 포트를 열어두고, 프로그램들이 전송을 할 수 있도록 제공해준다.(TCP, UDP) </p>
  <p>세션(Session): 데이터가 통신하기 위한 논리적 연결을 담당한다. TCP/IP 세션을 만들고 없애는 책임을 지니고 있다.(API, Socket) </p>
  <p>표현(Presentation): 데이터 표현에 대한 독립성을 제공하고 암호화하는 역할을 담당한다.(JPEG, MPEG) </p>
  <p>응용(Application): 최종 목적지로, 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.(HTTP, FTP, DNS ) </p>
</details>

<details>

  <summary>OSI7계층과 그 존재 이유, TCP/IP 4계층에 대해 설명해보세요.</summary>
  </br>
  <p>OSI7계층은 네트워크 통신을 구성하는 요소들 7개의 계층으로 표준화 한 것입니다. 이렇게 표준화함으로써 통신이 일어나는 과정을 단계별로 알 수 있고, 특정한 곳에 이상이 생기면 그 단계만 수정할 수 있기 때문이다.</p>
  <p> 실제로 우리가 대부분 사용하는 네트워크는 TCP/IP 4계층입니다. 통신에 실제로 사용되는 계층이고 1,2 계층이 1계층, 5, 6, 7계층이 4계층으로 운영됩니다.</p>
</details>

<details>
  <summary>웹 서버 소프트웨어(Apache, Nginx)의 서버 간 라우팅 기능은 OSI 7계층 중 어디서 작동하는지 설명해보세요.</summary>
  3계층인 네트워크 계층에서 이루어짐!
</details>


### 자료구조/알고리즘

보통의 자료구조/알고리즘적 지식은 코딩테스트로 검증합니다.  
하지만 아래의 개념을 적어도 이해는 한다고 생각하니, 혹시 모르는 부분이 있을 경우 학습을 권장합니다.

</details>
<details>
  <summary>트리</summary>
  </br>
-  정점과 간선을 이용해 사이클을 이루지 않도록 구성한 Graph의 특수한 형태로, 계층이 있는 데이터를 표현하기에 적합합니다.
</details>

<details>
  <summary>배열과 링크드 리스트의 차이를 설명해주세요.</summary>
  </br>
  <p>배열은 메모리상에 순서대로 데이터를 저장합니다. 반면 링크드 리스트는 자료의 주소값으로 서로 연결된 형태를 가지고 있어 다음 데이터의 위치에 대한 포인터를 가지고 있는 구조입니다.</p>
  <p>배열은 데이터를 인덱스로 조회할 수 있기 때문에 인덱스 조회 성능이 높고, 데이터가 메모리에 순서대로 저장되어 있기 때문에, 캐시의 지역성으로 인하여 비교적 빠르게 탐색을 수행할 수 있습니다.</p>
  <p>링크드 리스트는 중간에 데이터를 삽입하거나 삭제하는 것이 용이하다는 장점이 있습니다.</p>
</details>

</details>
<details>
  <summary>동적 프로그래밍(Dynamic Programming)</summary>
  </br>
- 주어진 문제를 풀기 위해서, 문제를 여러 개의 하위 문제(subproblem)로 나누어 푼 다음, 그것을 결합하여 해결하는 방식입니다.
- 조건
  - 중복되는 부분문제: 주어진 문제는 같은 부분 문제가 여러번 재사용된다
  - 최적 부분구조: 새로운 부분 문제의 정답을 다른 부분 문제의 정답으로부터 구할 수 있다
</details>

<details>
  <summary>재귀함수에 대해 설명하시오</summary>
  </br>
  <p>재귀함수란 함수 내에서 자기 자신을 다시 호출하는 형태로 소스코드의 간결화가 가능합니다.</p>
  <p>하지만 똑같은 연산을 반복할 수 있어 연산 시간이 오래 걸린다. 또한, 잘못 작성시 프로그램이 무한루프에 빠질 수 있다.</p>
</details>


<details>
<summary>List와 Set의 차이에 대해서 설명해주세요.</summary>
</br>
<p>List는 <b>중복</b>된 데이터를 저장하고 순서를 유지하는 선형 자료구조이고, Set은 <b>중복</b>되지 않은 데이터를 저장할 수 있고, 일반적으로 순서를 유지하지 않는 선형 자료구조입니다.(Set은 집합입니다., TreeSet과 같이 순서를 유지하는 Set도 존재합니다.) </p>
</details>

<details>
  <summary>Stack, Queue에 대해서 설명해주세요.</summary>
  </br>
  <p><b>Stack</b></p>
  <p>세로로 된 바구니와 같은 구조로 먼저 넣게 되는 자료가 마지막으로 나오게 되는 First-In Last-Out(FILO) 구조이. 스택의 사용 예시로는 웹 브라우저의 방문기록(뒤로가기), 실행 취소(undo) 등이 있습니다.(Array- 인덱스를 줄이고 초기화하면 되기 때문에)</p>
  <p><b>Queue</b></p>
  <p>가로로 된 통과 같은 구조로 먼저 넣게 되는 자료가 가장 먼저 나오는 First-In First-Out(FIFO) 구조입니다. 큐의 사용 예시로는 프린터의 인쇄 대기, 콜센터 고객 대기 시간 등이 있습니다.(LinkedList- 객체 1개만 제거하면되기 때문에 삽입 및 삭제가 용이한)</p>
</details>

<details>
  <summary>Heap, Priority Queue(우선 순위 큐)에 대해서 설명해주세요.</summary>
  </br>
  <p>Heap: 최댓값 또는 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 구조로, 각 노드의 키값이 자식의 키값보다 작지 않거나(최대힙) 그 자식의 키값보다 크지 않은(최소힙) 완전이진트리이다.</p>
  <p>완전 이진 트리의 일종으로 힙종류에는 부모 노드의 키 값이 자식 노드의 키캆보다 크거나 같은 최대 힙과 부모 노드의 키 값이 자식 노드으 키 값보다 작은 최소 힙이 존재합니다.</p>
  <p>Priority Queue: 가장 우선순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조입니다. 우선순위 큐를 구현하기 위해서 일반적으로 힙을 사용합니다. 힙은 완전이진트리를 통해서 구현되었기 때문에 우선순위 큐의 시간복잡도는 O(logn)입니다. 큐의 구조에 우선순위 개념을 도입하여 우선 순위가 높은 순서대로 먼저 빠져나가고 우선 순위가 같은 경우에는 FIFO으로 빠져나가는 것입니다. 우선순위 큐를 구현하기 위해서 일반적으로 힙을 사용합니다. 힙은 완전이진트리를 통해서 구현되었기 때문에 우선순위 큐의 시간복잡도는 O(logn)입니다.</p>
</details>

<details>
  <summary>[ 해시 테이블와 해시 테이블의 시간 복잡도 ]</summary>
  </br>
  <p>해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용합니다.</p>
  <p>해시 테이블은 Key값에 해시함수를 적용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조입니다.</p>
  <p>해시 테이블은 고유한 index로 값을 조회하기 때문에 평균적으로 O(1)의 시간복잡도를 갖습니다. 하지만 해시의 index값이 충돌이 발생한 경우 충돌된 index값에 대해 연결된 데이터들을 조회하여 원하는 값을 조회하기 때문에 O(N)까지 증가할 수 있습니다.</p>
</details>

<details>
  <summary>[삽입정렬, 선택 정렬, 버블소트, 힙소트, 머지(병합)소트, 퀵소트 ]</summary>
  </br>
  <p>삽입 정렬은 2번째 원소부터 시작하여 그 앞, 왼쪽 원소들과 비교하여 삽입할 위치를 지정한 후, 원소를 뒤로 옮기고 지정된 자리에 자료를 삽입 하여 정렬하는 알고리즘입니다. O(N)(원소가 먼저 선택)</p>
  <p>선택 정렬은 해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘이다.(자리가 먼저 선택)O(n^2) </p>
  <p>버블소트는 서로 인접한 두 원소를 비교하여 정렬하는 알고리즘입니다. 0번 인덱스부터 n-1번 인덱스까지 n번까지의 모든 인덱스를 비교하며 정렬합니다. 시간복잡도는 O(n2)O(n2) 입니다.</p>
  <p></p>
  <p>힙소트는 주어진 데이터를 힙 자료구조로 만들어 최대값 또는 최소값부터 하나씩 꺼내서 정렬하는 자료구조입니다. 힙소트가 가장 유용한 경우는 전체를 정렬하는 것이 아니라 가장 큰 값 몇개만을 필요로 하는 경우입니다. 시간복잡도는 O(nlog2n)O(nlog2n) 입니다.</p>
  <p>합병 정렬(머지 소트_)는 주어진 배열을 크기가 1인 배열로 분할하고 합병하면서 정렬을 진행하는 분할/정복 알고리즘입니다. 시간복잡도는 O(nlog2n)O(nlog2n) 입니다.</p>
  <p>퀵 소트:  분할 정복 알고리즘 중 하나로 합병정렬과 달리 리스트를 비균등하게 분할합니다. 피봇을 설정하고 피봇보다 큰값과 작은값으로 분할하여 정렬을 합니다. 시간복잡도는 O(nlog2n)O(nlog2n) 이며 리스트가 계속해서 불균등하게 나눠지는 경우 시간복잡도가 O(n2)O(n2) 까지 나빠질 수 있습니다.</p>
</details>

<details>
  <summary>Tree, Binary Tree, BST, AVL Tree에 대해서 설명해주세요.</summary>
  </br>
  <p>Tree: 정점과 간선을 이용해 사이클을 이루지 않도록 구성한 Graph의 특수한 형태로, 계층이 있는 데이터를 표현하기에 적합합니다.</p>
  <p>BST: Binary Search Tree로 이진 트리 기반의 탐색을 위한 자료구조로 중복된 데이터를 허용하지 않고, 부모의 키가 왼쪽 자식 노드의 키보다크고, 부모의 키가 오른쪽 자식 노드의 키보다 작습니다.</p>

  <p></p>
</details>

<details>
  <summary>BST의 최악의 경우의 예와 시간복잡도에 대해서 설명해주세요.</summary>
  </br>
  <p>BST가 아닌 Self-Balanced Tree를 사용하는 이유에 대해서 생각해보았다면 쉽게 답할 수 있는 문제입니다.</p>
  <p>예를들어 1부터 10까지 순차적으로 BST에 저장했다면, BST의 형태는 리스트와 같아집니다. 이 경우를 최악의 경우라고 하며 시간복잡도는 O(n)이 됩니다.</p>
</details>

<details>
  <summary>피보나치 수열을 코드로 구현하는 방법에 대해서 설명해주세요.</summary>
  </br>
  <p>피보나치 수열은 보통 재귀정도로 구현할 수 있지만, 중복된 연산이 계속해서 발생하게 됩니다. 이런 중복된 연산을 메모리 등에 저장해두고 해당 결과가 존재하지 않을 때만 연산을 수행하도록 하면 보다 빠른 동작을 구현할 수 있게됩니다.</p>
</details>

<details>
  <summary>DFS, BFS에 대해서 설명해주세요.</summary>
  </br>
  <p>DFS: 깊이 우선 탐색으로 그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 한 정점으로만 나아갑니다.(스택, 재귀함수)</p>
  <p>BFS: 너비 우선 탐색으로 그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 모든 정점으로 나아갑니다.(큐)</p>
</details>

<details>
  <summary>동적 계획법에 대해서 설명해주세요.</summary>
  </br>
  <p>한 가지 문제에 대해서, 단 한 번만 풀도록 만들어주는 알고리즘이다.</p>
  <p> 똑같은 연산을 반복하지 않도록 만들어준다. 실행 시간을 줄이기 위해 많이 이용되는 수학적 접근 방식의 알고리즘이라고 할 수 있다.</p>
</details>

<details>
  <summary>정렬, 탐색에 대해 설명해주세요.</summary>
  </br>
  <p>정렬이 필요한 이유 정렬이 되어 있다면 자료 탐색에 있어서 편리함을 가질 수 있기 때문입니다.</p>
</details>

### 운영체제

</details>
<details>
  <summary>Byte Ordering이란</summary>
  </br>
- 데이터가 저장되는 순서를 의미합니다
- Big Endian
  - MSB가 가장 낮은 주소에 위치하는 저장 방식
- Little Endian
  - MSB가 가장 높은 주소에 위치하는 방식
</details>

<details>
  <summary>프로세스와 스레드의 차이를 설명해보세요.</summary>
  </br>
  <p>프로세스는 메모리에 올라와있고 실행중인 프로그램의 인스턴스을 의미합니다. 스레드는 프로세스 내에서 할당받은 자원을 이용해 동작하는 실행단위합니다.</p>
  <p>프로세스는 운영체제로부터 자원을 할당받지만, 스레드는 프로세스로부터 자원을 할당받고, 프로세스의 스택은 할당받고 코드/데이터/힙영역을 공유하기 때문에 좀 더 효율적으로 통신할 수 있습니다. 또한 컨텍스트 스위칭도 캐시 메모리를 비우지 않아도 되는 스레드쪽이 빠릅니다.</p>
  - 프로세스는 독립된 메모리 영역을 할당 받고, 독립적이기 때문에 통신하기 위해 IPC를 사용해야 합니다.
  - 스레드는 프로세스의 자원을 공유하기 때문에 다른 스레드이 결과를 즉시 확인 가능합니다.
  <p>한 프로세스 안에 여러개의 스레드가 생성될 수 있습니다.</p>
</details>

<details>
  <summary>컨텍스트 스위칭에 대해 설명해보세요.</summary>
  </br>
  <p>컨텍스트 스위칭은 한 Task가 끝날 때까지 기다리는 것이 아니라 여러 작업을 번갈아가며 실행해서 동시에 처리될 수 있도록 하는 방법입니다.</p>
  인터럽트를 발생시켜 CPU에서 실행중인 프로세스를 중단하고, 다른 프로세스를 처리하기 위한 과정입니다
  <p>동작 중인 프로세스가 대기하면서 해당 프로세스의 상태를 보관하고, 대기하고 있던 다음 순번의 프로세스가 동작하면서 이전에 보관했던 프로세스 상태를 복구하는 과정을 말합니다.</p>
  <p>인터럽트가 발생하면 현재 프로세스의 상태를 PCB에 저장하고 새로운 프로세스의 상태를 레지스터에 저장하는 방식으로 동작합니다. 이때, CPU는 아무런 일을 하지 않으므로 잦은 컨텍스트 스위칭은 성능저하를 일으킬 수 있습니다.</p>
  <p>스레드와 프로세스의 동작방식이 약간 상이한데, 스레드는 캐시메모리나 PCB에 저장해야하는 내용이 적고, 비워야 하는 내용도 적기때문에 상대적으로 더 빠른 컨텍스트 스위칭이 일어날 수 있습니다.</p>
</details>

</details>
<details>
  <summary> PCB(Process control block)</summary>
  </br>
- 운영체제가 프로세스를 제어하기 위해 정보를 저장해놓는 곳으로 프로세스의 상태 정보를 저장하는 구조체입니다.
- 주 기억장치에 유지됩니다.
</details>

<details>
  <summary>프로세스의 주소 공간</summary>
  </br>
  <p>프로세스 주소 공간에는 코드, 데이터, 스택으로 이루어져 있습니다. 최대한 데이터를 공유하여 메모리 사용량을 줄이기 위해 이렇게 구역을 나눕니다.</p>
    <p>코드 Segment : 프로그램 소스 코드 저장.</p>
    <p>데이터 Segment : 전역 변수 저장</p>
    <p>스택 Segment : 함수, 지역 변수 저장</p>
  <p>Code는 같은 프로그램 자체에서는 모두 같은 내용이기 때문에 따로 관리하여 공유한다. </p>
  <p>Stack과 data를 나눈 이유는, 스택 구조의 특성과 전역 변수의 활용성을 위한 것이다.(프로그램의 함수와 지역 변수 LIFO - 스택)</p>
</details>

<details>
  <summary>인터럽트</summary>
  </br>
  <p>프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황에 대한 우선 처리가 필요함을 CPU에게 알리는 것입니다.</p>
    <p>외부/내부 인터럽트는 CPU의 하드웨어 신호에 의해 발생(외부 - 입출력 장치, 타이밍 장치, 전원 등 외부적인 요인으로 발생) (내부 - Trap이라고 부르며, 잘못된 명령이나 데이터를 사용할 때 발생)</p>
    <p>소프트웨어 인터럽트는 명령어의 수행에 의해 발생(프로그램 처리 중 명령의 요청에 의해 발생한 것)</p>
  1. 프로그램 실행
  2. 인터럽트 발생
  3. 복귀주소 저장(현재 수행 중인 프로그램을 멈추고, 상태 레지스터와 PC 등을 스택에 잠시 저장한 뒤에 인터럽트 서비스 루틴으로 간다. (잠시 저장하는 이유는, 인터럽트 서비스 루틴이 끝난 뒤 다시 원래 작업으로 돌아와야 하기 때문)
  4. 인터럽트 벡터로 점프
  5. 인터럽트 처리
  6. 인터럽트 처리 완료
  7. 복귀주소 로드
  8. 마지막에 실행되던 주소로 점프
  9. 주 프로그램 실행
</details>

<details>
  <summary>블로킹, 넌블로킹/ 장단점에 대해 설명해보세요.</summary>
  </br>
  <p>블로킹 방식은 대상의 작업이 끝날 때 까지 제어권을 대상이 가지고 있는 것을 의미합니다. 반면에 논블로킹은 대상의 작업 완료여부와 상관없이 새로운 작업을 수행합니다.</p>
  <p>동기 논블로킹은 계속해서 polling을 수행하기 때문에 컨텍스트 스위칭이 지속적으로 발생해 지연이 발생합니다.</p>
</details>

</details>
<details>
  <summary>멀티 프로세스</summary>
  </br>
- 하나의 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 1개의 작업을 처리하도록 하는 것
</details>

<details>
  <summary>멀티스레드 프로그래밍에 대해 설명해보세요.</summary>
  </br>
  하나의 프로그램을 여러 개의 쓰레드로 구성하여 각 쓰레드가 1개의 작업을 처리하도록 하는 것
  <p>멀티스레드 프로그래밍은 하나의 프로세스에서 여러개의 스레드를 만들어 자원의 생성과 관리의 중복을 최소화하는 것을 멀티스레드 프로그래밍이라고 합니다.</p>
  <p>장점
    <ul>
      <li>멀티 프로세스에 비해 메모리 자원소모가 줄어듭니다.</li>
      <li>힙 영역을 통해서 스레드간 통신이 가능해서 프로세스간 통신보다 간단합니다.</li>
      <li>스레드의 컨텍스트 스위칭은 프로세스의 컨텍스트 스위칭보다 빠릅니다.</li>
    </ul>
  </p>
  <p>단점
    <ul>
      <li>힙 영역에 있는 자원을 사용할 때는 동기화를 해야합니다.</li>
      <li>동기화를 위해서 락을 과도하게 사용하면 성능이 저하될 수 있습니다.</li>
      <li>하나의 스레드가 비정상적으로 동작하면 다른 스레드도 종료될 수 있습니다.</li>
    </ul>
  </p>
</details>

</details>
<details>
  <summary>멀티 쓰레드 프로그래밍 작성 시 유의점</summary>
  </br>
- 멀티 쓰레드 프로그램을 개발한다면, 다수의 쓰레드가 공유 데이터에 동시에 접근하는 경우에 상호 배제를 제거해 교착 상태를 예방하고 동기화 기법을 통해 동시성 문제가 발생하지 않도록 발생하지 않도록 주의해야 합니다.
</details>

<details>
  <summary>프로세스 동기화에 대해 설명해보세요.</summary>
  </br>
  <p>다중 프로세스 환경에서 자원 등에 한 프로세스만이 접근가능하도록 하는 것입니다.</p>
  <p>프로세스 동기화를 하지 않으면 데이터의 일관성이 깨지기 때문에 연산결과가 잘못 반환될 가능성이 존재하기 때문에 주의해야 합니다.</p>
  <p>Race Condition(경쟁 상태): 여러 프로세스나 스레드가 동기화 메커니즘 없이 자원에 접근하려는 상황을 가리킵니다. 공유된 자원에 대한 접근 순서에 따라 실행 결과가 달라질 수 있는 상황을 의미합니다.</p>
  <p>Critical Section(임계 구역): 여러 스레드가 동시에 접근해서는 안되는 공유자원에 접근하는 코드 블럭을 얘기합니다. 한 임계구역에 하나의 스레드 혹은 프로세스만 접근이 가능합니다. 임계 구역에 접근하는 것을 제어하기 위해 세마포어, 뮤텍스와 같은 매커니즘을 사용합니다.</p>
  <p>임계 구역 문제를 해결하기 위한 조건(모두 충족해야함)
    <ul>
      <li>상호 배제(Mutual Exclusion): 한 프로세스가 임계구역에서 동작중이면 다른 프로세스는 접근할 수 없다.</li>
      <li>진행(Progress): 임계구역에서 작업중인 프로세스가 없다면 입계구역으로 진입하려는 프로세스를 적절히 선택해서 진입할 수 있도록 합니다.</li>
      <li>유한 대기(Bounded Waiting): 한 프로세스가 임계영역으로 진입을 요청한 후 다른 프로세스는 진입이 유한한 횟수로 제한되어야 합니다. (기아상태 방지)</li>
    </ul>
  </p>
</details>

<details>
  <summary>교착상태(데드락)와 기아상태의 해결방법에 대해 설명해보세요.</summary>
  </br>
  <p>교착상태(Deadlock)가 한정된 자원을 여러 프로세스가 사용하고자 할 때 발생하는 상황으로, 프로레스가 자원을 얻기 위해 영구적으로 기다리는 상태입니다.</p>
  <p>발생조건
    <ul>
      <li>상호 배제: 한 번에 한 프로세스만 해당 자원을 사용할 수 있어야 합니다.</li>
      <li>점유 대기: 할당된 자원을 가진 상태에서 다른 자원을 기다립니다.</li>
      <li>비선점: 다른 프로세스가 자원의 사용을 끝낼 때 까지 자원을 뺏을 수 없습니다.</li>
      <li>순환대기: 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있습니다.</li>
    </ul>
  </p>
  <p>해결방법
    <ul>
      <li>예방: 4가지 조건 중 하나라도 만족되지 않도록 합니다.</li>
      <li>회피: 알고리즘을 데드락이 발생하지 않도록 합니다.</li>
      <li>회복: 교착상태가 발생할 때, 해결합니다.</li>
      <li>무시: 회복과정의 성능저하가 심하다면 그냥 무시합니다.</li>
    </ul>
  </p>
  <p>기아상태(Starvation): 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스가 영원히 자원 할당이 되지 않는 경우입니다.</p>
  <p>우선순위를 변경합니다.(우선순위를 수시로 변경하거나, 오래 기다린 프로세스의 우선순위를 높여주거나, Queue를 사용합니다.)</p>
</details>

<details>
  <summary>세마포어와 뮤텍스의 차이에 대해 설명해보세요.</summary>
  </br>
  <p>세마포어는 여러 개의 프로세스가 접근 가능한 공유자원을 관리하는 방식이고, 뮤텍스가 될 수 있지만, 뮤텍스는 한 번에 한 개의 프로세스만 접근 가능하도록 관리하는 방식입니다. 따라서 뮤텍스는 세마포어가 될 수 없습니다.</p>
  <p>또, 세마포어는 다른 프로세스가 세마포어를 해제할 수 있지만, 뮤텍스는 락을 획득한 프로세스만 락을 반환할 수 있습니다.</p>
</details>

<details>
  <summary>가상 메모리에 대해 설명해보세요.</summary>
  </br>
  - 가상 메모리는 RAM의 부족한 용량을 보완하기 위해, 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 할당하는 방식입니다.
  - 페이지 폴트는 CPU는 프로세스를 실행하면서 페이지 테이블을 통해 페이지를 조회하는데, 실제메모리에 원하는 페이지가 없는 상황이 발생할 수 있습니다. 이것이 발생하게 되면 가상 메모리를 통해 해당 데이터를 가져오게 됩니다.
  <p>Swap 영역, 실제 메모리에서 공간이 부족한 경우 보조 기억 장치에서 임시로 사용하는 영역입니다.</p>
  <p>OS 에서 관리하며 프로세스는 이것이 실제 메모리인지, Swap 영역인지 모릅니다. Java에서는 Swap 영역을 잡아주지 않은 경우 OOM이 발생할 수 있습니다.</p>
  <p>당연히 실제 메모리가 아니기 때문에 지연시간이 많이 발생하며, 가급적이면 swap메모리를 사용하지 않도록 설계하는 것이 좋고, 만약 계속해서 사용하는 양이 증가한다면 메모리 누수를 의심해 볼 수 있습니다.</p>
</details>

</details>
<details>
  <summary>페이지 교체 알고리즘과 LRU(Least Recently Used)</summary>
  </br>
- 제메모리의 페이지들 중에서 가장 오랫동안 사용되지 않은 페이지를 선택하는 방식입니다.
</details>

<details>
  <summary>캐시의 지역성에 대해 설명해보세요.</summary>
  </br>
  <p>시간 지역성과 공간 지역성으로 나눌 수 있으며, 시간 지역성은 최근에 접근한 데이터에 다시 접근하는 경향을 의미하고, 공간 지역성은 최근 접근한 데이터의 주변 공간에 다시 접근하는 경향을 의미합니다.</p>
</details>

<details>
  <summary>프로세스 관련 용어를 설명해보세요. (알아만 둡시다.)</summary>
  </br>
  <p>PCB: 프로세스 제어 블록, 프로세스에 대한 중요한 정보를 저장합니다.</p>
  <p>PC: 프로그램 카운터, 프로세스 실행을 위한 다음 명령의 주소를 표시합니다.</p>
  <p>캐시메모리: 자주 사용되는 데이터가 저장되는 공간으로 CPU의 레지스터와 메모리 사이에서 병목 현상을 완화하는 장치입니다.</p>
</details>

### 데이터베이스

<details>
  <summary>데이터베이스에서 인덱스를 사용하는 이유 및 장단점에 대해 설명해주세요.</summary>
  </br>
  <p>데이터베이스에서 인덱스를 사용하는 이유는 검색성능을 향상시키기 위함입니다.</p>
  <p>하지만 검색성능을 실질적으로 향상시키기 위해서는 해당 쿼리가 index를 사용하는지, 카디널리티, Selectivity 같은 요소들이 고려된 인덱스가 생성되어야 합니다.</p>
  <p>일반적인 경우의 장점으로는 빠른 검색 성능을 들 수 있습니다.</p>
  <p>일반적인 경우의 단점으로는 인덱스를 구성하는 비용 즉, 추가, 수정, 삭제 연산시에 인덱스를 형성하기 위한 추가적인 연산이 수행됩니다.</p>
  <p>따라서, 인덱스를 생성할 때에는 트레이드 오프 관계에 놓여있는 요소들을 종합적으로 고려하여 생성해야합니다.</p>
</details>

</details>
<details>
  <summary>인덱스의 자료구조 </summary>
  </br>
해시 테이블
- 컬럼의 값으로 생성된 해시를 기반으로 인덱스를 구현한다.
- 시간복잡도가 O(1)이라 검색이 매우 빠르다.
- 부등호(<, >)와 같은 연속적인 데이터를 위한 순차 검색이 불가능하다.


B+Tree
- 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다.
- BTree의 리프노드들을 LinkedList로 연결하여 순차 검색을 용이하게 하였다.
- 해시 테이블보다 나쁜 O(log2nlog2n{log_2n}) 의 시간복잡도를 갖지만 해시테이블보다 흔하게 사용된다.
</details>

<details>
  <summary>트랜잭션에 대해서 설명해주세요.</summary>
  </br>
  <p>트랜잭션이란 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위로, 트랜잭션에는 여러개의 연산(Select, insert, delete, update)이 수행될 수 있습니다.</p>
  <p>트랜잭션은 수행중에 한 작업이라도 실패하면 전부 실패하고, 모두 성공해야 성공이라고 할 수 있습니다.</p>
  <p>commit: 하나의 트랜잭션이 성공적으로 끝났고, DB가 일관성있는 상태일 때 이를 알려주기 위해 사용하는 연산입니다.</p>
  <p>rollback: 하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션 원자성(트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 된다.)이 깨진 경우입니다.</p>
  <p>undo: 정상적으로 종료되지 않은 transaction이 변경한 page들은 원상 복구 되어야 하는데, 이 복구를 undo라고 합니다.</p>
  <p>redo: commit한 transaction의 수정을 재반영하는 복구 작업입니다.</p>
</details>

<details>
  <summary>트랜잭션 ACID에 대해서 설명해주세요.</summary>
  </br>
  <p>ACID는 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질입니다.</p>
  <p>
    <ul>
      <li>Atomicity(원자성): 트랜잭션의 연산은 모든 연산이 완벽히 수행되어야 하며, 한 연산이라도 실패하면 트랜잭션은 실패해야 합니다.</li>
      <li>Consistency(일관성): 트랜잭션은 유효한 상태로만 변경될 수 있습니다.</li>
      <li>Isolation(고립성): 트랜잭션은 동시에 실행될 경우 다른 트랜잭션에 의해 영향을 받지 않고 독립적으로 실행되어야 합니다.</li>
      <li>Durability(내구성): 트랜잭션이 커밋된 이후에는 시스템 오류가 발생하더라도 커밋된 상태로 유지되는 것을 보장해야 합니다. (일반적으로 비휘발성 메모리에 데이터가 저장되는 것을 의미)</li>
    </ul>
  </p>
</details>

</details>
<details>
  <summary>이상 현상</summary>
  </br>
- 삭제 이상
- 삽입 이상: 튜플 삽입 시 특정 속성에 해당하는 값이 없어 NULL을 입력해야 하는 현상
- 수정 이상: 튜플 수정 시 중복된 데이터의 일부만 수정되어 일어나는 데이터 불일치 현상
</details>

<details>
  <summary>정규화에 대해서 설명해주세요.</summary>
  </br>
  <p>정규화는 데이터의 중복방지, 무결성을 충족시키기 위해 데이터베이스를 설계하는 것을 의미합니다.</p>
  <p>제 1정규화: 테이블 컬럼이 원자값(하나의 값)을 갖도록 테이블을 분리시키는 것을 말합니다.</p>
  <p>제 2정규화: 테이블의 모든 컬럼이 기본키가 아닌 속성이 완전 함수적 종속을 만족해야 한다는 것입니다. 즉 기본키의 부분집합 키가 결정자가 되어서는 안된다는 것입니다. </p>
  <p>제 3정규화(3NF): 기본키가 아닌 속성이 직접 종속(비이행적 종속)을 하도록 테이블을 분리하는 것을 말합니다. </p>
  <p>제 4정규화: 모든 결정자가 후보키가 되도록 테이블을 분해하는 것을 말합니다. </p>
</details>

<details>
  <summary>JOIN에 대해서 설명해주세요.</summary>
  </br>
  <p>두 개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법을 말합니다.</p>
</details>

<details>
  <summary>RDBMS vs NOSQL에 대해서 설명해주세요.</summary>
  </br>
  <p>RDBMS는 데이터베이스를 이루는 객체들의 릴레이션을 통해서 데이터를 저장하는 데이터베이스입니다. SQL을 사용해 데이터의 저장, 질의, 수정, 삭제를 할 수 있으며 데이터를 효율적으로 보관하는 것을 목적으로 하고 구조화가 굉장히 중요합니다.</p>
  - 2차원의 행과 열로 데이터의 관계를 관리하는 데이터베이스
- 스키마에 맞추어 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있습니다.
  <p>NOSQL은 RDBMS가 비대해짐에 따라 관계가 복잡해져, 이를 극복하기 위해 등장하게 된 데이터베이스로 RDBMS에 비해 자유로운 형태로 데이터를 저장합니다. 또한 수평확장을 할 수 있고 분산처리를 지원합니다. 다양한 형태의 NOSQL 데이터베이스가 있고, 대표적으로 key-value store, bigtable, dynamo, document db, graph db 등이 있습니다.</p>
  - 스키마 없이 Key-Value 형태로 데이터를 관리하여 좀 더 자유롭게 데이터를 관리할 수 있다
  <p>둘은 대체될 수 있는 것이 아니고, 각각 필요한 시점에 적절히 선택해서 사용해야 합니다. 둘 다 같이쓰는 상호보완적인 존재가 될 수도 있습니다.</p>
</details>

<details>
  <summary>Elastic Search에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p>Elastic Search는 자바로 개발된 오픈소스 검색엔진 입니다. 보통 단독으로 사용하기보다는 ELK 스택이라고 부르는 </p>
  <p>Inverted Index 구조로 데이터를 저장해서, 전문(Full-text) 검색시에 RDBMS에 비해 뛰어난 성능을 보장합니다.</p>
  <p>다양한 용도로 사용할 수 있습니다. (데이터 저장, 문서 검색, 위치 검색, 머신 러닝 기반 검색, 로그 분석, 보안 감사 분석 등)</p>
</details>

<details>
  <summary>Elastic Search의 인덱스구조와 RDBMS의 인덱스 구조의 차이에 대해 설명해주세요.</summary>
  </br>
  <p>Elastic Search는 Inverted-Index 구조로 데이터를 저장합니다. 이는 책의 색인을 생각해보면 쉬운데, 특정 단어가 출현하는 doc을 저장하는 것입니다. 반면 RDBMS는 B-Tree와 그와 유사한 인덱스를 사용합니다. 데이터가 어디에 존재하는지 어떤 순서로 저장하는 지의 차이라고 생각합니다. RDBMS에도 다양한 인덱스 구조가 있으나 여기서 예로 든 것은 B-Tree 인덱스입니다.</p>
</details>

<details>
  <summary>Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.</summary>
  </br>
  <p>Elastic Search의 키워드 검색은 document를 저장할 때 수행하는 알고리즘과 동일한 알고리즘으로 키워드를 분리합니다. 그 중에서 랭킹알고리즘을 통해서 가장 유사한 순서대로 결과를 나타냅니다.</p>
  <p>RDBMS에서의 LIKE 검색은 와일드카드로 시작하지 않는 경우에만 인덱스를 사용하고 나머지 경우는 전체를 탐색하기 때문에 상대적으로 느립니다.</p>
</details>


<details>
  <summary>CAP 이론과, Eventual Consistency에 대해서 설명해주세요.</summary>
  </br>
  <p>CAP 이론은 분산 환경에서 모두를 만족하는 시스템은 없다는 이론입니다.</p>
  <p>
    <ul>
      <li>Consitenty(일관성): ACID의 일관성과는 약간 다릅니다. 모든 노드가 같은 시간에 같은 데이터를 보여줘야 한다는 것입니다.</li>
      <li>Availability(가용성): 모든 동작에 대한 응답이 리턴되어야 합니다.</li>
      <li>Partition Tolerance(분할 내성): 시스템 일부가 네트워크에서 연결이 끊기더라도 동작해야 합니다.</li>
    </ul>
  </p>
  <p>Eventual Consistency는 이 Consistency를 보장해주지 못하기 때문에 나온 개념으로, Consistency를 완전히 보장하지는 않지만, 결과적으로 언젠가는 Conssistency가 보장됨을 의미합니다.</p>
</details>

### 암호학/보안(간단한 정도)

<details>
  <summary>비대칭키 암호화, 대칭키 암호화에 대해 간단히 설명해주세요.</summary>
  </br>
  <p>비대칭키 암호화란 공개키 암호화라고도 하며, 공개키는 외부에 공개되어있고, 비밀키는 내부적으로 가지고 있고 서로 각각의 키로 암호화하거나 해제할 수 있는 방식입니다. 이 방식은 대칭키를 공유하는 방식보다 비교적 안전하며, 대신 연산 성능이 떨어지는 편입니다.</p>
  <p>대칭키 암호화란 양측이 동일한 키를 가지고 있으며, 암호화와 해제에 동일한 키를 사용하는 방식입니다. 이 방식은 비밀키가 노출되는 문제가 있을 수 있으며, 연산성능은 덜 필요해 상대적으로 빠릅니다.</p>
</details>

<details>
  <summary>단방향 암호화에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p>단방향 암호화는 복호화 불가능한 암호화라고 합니다. 대부분 해시 알고리즘을 이용해서 구현하며, 민감정보를 데이터베이스에 저장할 때, 해당 방식을 사용합니다.</p>
  <p>보통의 단방향 암호화는 빠른 성능을 보여, 무차별 대입 공격에 취약합니다. 따라서 이런 정보를 저장하기 위해 bcrypt와 같은 방식을 사용합니다.</p>
  <p>해시란 말에서 알 수 있듯이 충돌가능성이 있습니다. 이렇게 복호화 불가능한 암호화 방식이 위험하다는 것은 해시 충돌을 일으켰다는 말로 이해해도 됩니다.</p>
</details>

<details>
  <summary>JWT에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p>JWT란 토큰 인증 방식에서 쓰이는 것입니다.</p>
  <p>이것은 헤더, 페이로드, 시그니쳐로 구분됩니다. 헤더는 토큰의 타입, 암호화 알고리즘을 담고 있고, 페이로드는 토큰의 정보를 담는 부분이며, 시그니처는 토큰의 정보가 신뢰할 수 있는것인지 판단할 수 있도록 합니다.</p>
  <p>JWT는 세션 기반 인증과 주로 대비됩니다. 세션기반 인증은 서버에서 세션 정보를 관리해야하는 비용이 들게됩니다. 또한 분산환경에서도 관리하기 어렵습니다. 하지만 JWT는 그 자체로 정보를 가지고 있기 때문에 세션의 단점을 보완할 수 있습니다.</p>
  <p>JWT와 다른 토큰 기반 인증 방식을 비교하는 질문이 나온적도 있습니다.</p>
</details>

<details>
  <summary>OAuth에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p>OAuth는 제3자 인증방식 입니다. 기본적으로 사용자는 서버를 신뢰할 수 없습니다. 그렇기 때문에, 민감정보를 작성하는 것을 꺼립니다. </p>
  <p>OAuth를 사용해서 신뢰할 수 있는 서버에게 정보를 맡겨놓고 접근할 수 있는 권한을 주는 것 입니다. 그러면 사용자 측에서는 민감정보를 굳이 입력하지 않고도 서비스를 사용할 수 있고, 서버측에서도 민감정보를 굳이 관리하지 않아도 되기 때문에 이점이라고 볼 수 있습니다.</p>
</details>

<details>
  <summary>JWT와 OAuth의 차이는 무엇이 있을까요?</summary>
  </br>
</details>

<details>
  <summary>SQL Injection에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p>해커에 의해 조작된 SQL 쿼리문이 데이터베이스에 그대로 전달되어 비정상적 명령을 실행시키는 공격 기법을 말합니다.</p>
</details>

<details>
  <summary>CSRF에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p>웹 어플리케이션 취약점 중 하나로, 인터넷 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위 (modify, delete, register 등)를 특정한 웹사이트에 request하도록 만드는 공격을 말합니다.</p>
  <p>리퍼러(Refferer) 검증</p>
  <p>Security Token 사용</p>
</details>

<details>
  <summary>XSS에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p>CSRF와 같이 웹 어플리케이션 취약점 중 하나로, 관리자가 아닌 권한이 없는 사용자가 웹 사이트에 스크립트를 삽입하는 공격 기법을 말합니다.</p>
  <p></p>
</details>

### 컴파일러

<details>
  <summary>스크립트 언어와 컴파일 언어를 나열하고 차이점을 설명해주세요.</summary>
  </br>
  <p>스크립트 언어는 PHP, Javascript, Python이 대표적인 스크립트 언어입니다. 컴파일 언어는 C, C++, Swift, Go가 있습니다.</p>
  <p>Java는 조금 특수한 경우입니다. Java는 컴파일 시에 Java Byte Code로 컴파일 되며, 이는 JVM에서 인터프리터 방식으로 동작합니다. 하지만 JIT Compiler라는 기술과 Hotspot JVM이라는 기술의 합작으로 네이티브 언어와 유사한 수준의 퍼포먼스를 낼 수 있게 되었습니다.</p>
  <p>스크립트 언어와 컴파일 언어의 차이점은 스크립트 언어는 인터프리터라는 방식으로 한 라인 한 라인 기계어로 번역하며 실행하고, 우리가 컴파일 에러라고 부르는 문법 오류를 사전에 방지하지 못하기 때문에 주의해야 합니다. 바로바로 실행하기에는 좋기 때문에 해당 방식이 필요한 분야에 많이 사용됩니다. 컴파일 언어는 컴파일 과정을 거쳐 기계어 코드로 번역이 되기 때문에 사전에 검증을 할 수 있고, 최적화를 해줄 수 있습니다. 이것이 컴파일러가 가지는 장점입니다.</p>
</details>

## 언어 관련

### Java
<details>
  <summary>JVM의 구조와 Java의 실행방식을 설명해주세요.</summary>
  </br>
  <p>자바 가상 머신의 약자를 따서 줄여 부르는 용어로 JVM의 역할은 자바 애플리케이션을 클래스 로더를 통해 읽어 자바 API와 함께 실행하는 것입니다. 메모리 관리(GC)을 수행하며 스택기반의 가상머신입니다.</p>
  <p>JVM의 구조는 Class Loader, Exection engine, Runtime Data Area, JNI, Native Method Library로 이루어져 있습니다.</p>
  <ul>
    <li>클래스 로더: JVM내로 클래스를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈</li>
    <li>실행 엔진: 바이트 코드를 실행시키는 역할</li>
    <ul>
      <li>인터프리터: 바이트 코드를 한줄 씩 실행합니다.</li>
      <li>JIT 컴파일러: 인터피르터 효율을 높이기 위한 컴파일러로 인터프리터가 반복되는 코드를 발견하면 JIT 컴파일러가 반복되는 코드를 네이티브 코드로 바꿔줍니다. 그 다음부터 인터프리터는 네이티브 코드로 컴파일된 코드를 바로 사용합니다.</li>
      <li>GC(Garbage Collector): 가비지 컬렉터로 힙 영역에서 사용되지 않는 객체들을 제거하는 작업을 의미합니다.</li>
    </ul>
    <li>Runtime Data Areas: 프로그램 실행 중에 사용되는 다양한 영역입니다.</li>
    <ul>
      <li>PC Register: Thread가 시작될 때 생성되며 현재 수행 중인 JVM 명령의 주소를 갖고 있습니다.</li>
      <li>Stack Area: 지역 변수, 파라미터 등이 생성되는 영역. 실제 객체는 Heap에 할당되고 해당 레퍼런스만 Stack에 저장됩니다.</li>
      <li>Heap Area: 동적으로 생성된 오브젝트와 배열이 저장되는 곳으로 GC의 대상 영역입니다.</li>
      <li>Method Area: 클래스 멤버 변수, 메소드 정보, Type 정보, Constant Pool, static, final 변수 등이 생성됩니다. 상수 풀(Constant Pool)은 모든 Symbolic Reference를 포함하고 있습니다.</li>
    </ul>
    <li>JNI(Java Native Interface): 자바 애플리케이션에서 C, C++, 어셈블리어로 작성된 함수를 사용할 수 있는 방법을 제공해줍니다. Native 키워드를 사용하여 메서드를 호출합니다. 대표적인 메서드는 Thread의 currentThread()입니다.</li>
    <li>Native Method Library: C, C++로 작성된 라이브러리 입니다.</li>
  </ul>
  <p>Java의 실행방식
    <ul>
    <li>자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어 자바 바이트코드(.class)로 변환시킵니다.</li>
    <li>Class Loader를 통해 class 파일들을 JVM으로 로딩합니다.</li>
    <li>로딩된 class파일들은 Execution engine을 통해 해석됩니다.</li>
    <li>해석된 바이트코드는 Runtime Data Areas 에 배치되어 실질적인 수행이 이루어집니다.</li>
    </ul>
  </p>
</details>

<details>
  <summary>GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.</summary>
  </br>
  <p>GC는 힙 영역에서 사용하지 않는 객체들을 제거하는 작업을 총칭합니다. 이 객체를 제거하는 작업이 필요한 이유는 자바는 개발자가 메모리를 직접 해제해줄 수 없는 언어이기 때문입니다. </p>
  <p>GC의 동작방식은 가장 간단한 Serial GC 방식으로 설명할 수 있습니다. 좀 더 진보된 GC는 G1 GC, ZGC가 있으며 여기선 다루지 않습니다.</p>
  <p>GC는 Minor GC, Major GC로 구분할 수 있습니다. Minor GC는 young 영역에서, Major GC는 old 영역에서 일어난다고 정의합니다.  GC를 수행할 때는 GC를 수행하는 스레드 이외의 스레드는 모두 정지합니다. 이를 Stop-the-world라고 합니다.</p>
  <p>Minor GC는 Eden 영역이 가득 찰 때 부터 시작됩니다. Eden 영역에서 참조가 남아있는 객체를 mark하고 survivor 영역으로 복사합니다. 그리고 Eden 영역을 비웁니다. Survivor 영역도 가득차면 같은 방식으로 다른 Survivor 영역에 복사하고 비웁니다. 이를 반복하다 보면 계속 해서 살아남는 객체는 old 영역으로 이동하게 됩니다.</p>
  <p>old 영역에서 일어나는 Major GC는. 위와 반대로 삭제되어야 하는 객체를 mark합니다. 그리고 지웁(sweep)니다. 메모리는 단편화 된 상태이므로 이를 한 군데에 모아주는 것을 Compaction이라 하며 compact라고 합니다. 그래서 Mark-Sweep-Compact 알고리즘이라고 합니다.</p>
  <p>이것이 중요한 이유는 GC 수행시 시스템이 멈추기 때문에 의도치 않은 장애의 원인이 될 수 있습니다. 따라서 이를 위해 힙 영역을 조정하는 것을 GC 튜닝이라고 하고 JVM 메모리는 절대 마음대로 조정해선 안됩니다.</p>
</details>

<details>
  <summary>컬렉션 프레임워크에 대해서 설명해주세요.</summary>
  </br>
  <p>Java Collection은 널리 알려져 있는 자료구조를 바탕으로 객체, 데이터들을 효율적으로 관리 할 수 있는 자료구조들이 있는 라이브러리입니다.</p>
  <p>List, Set은 Collection 인터페이스을 상속받지만, Map 인터페이스는 구조상의 차이라 별도로 정의합니다.</p>
</details>

<details>
  <summary>제네릭에 대해서 설명해주세요.</summary>
  </br>
  <p>제네릭은 자바의 타입 안정성을 맡고 있습니다. 컴파일 과정에서 타입체크를 해주는 기능으로 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여줍니다.</p>
</details>

<details>
  <summary>어노테이션에 대해서 설명해주세요.</summary>
  </br>
  <p>어노테이션은 인터페이스를 기반으로 한 문법으로 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있습니다. 예를들어, built-in annotation은 상속받아서 메소드를 오버라이드 할 때 나타나는 @Override 애노테이션있습니다.</p>
  <p>메타 애너테이션은 애노테이션을 선언할 때 사용하는 애노테이션입니다.</p>
  <ul>
    <li>@Retention: 애노테이션 유지 범위를 지정합니다. (소스, 클래스, 런타임)</li>
    <li>@Inherit: 애노테이션을 하위 클래스까지 전달여부를 지정합니다. 이 애노테이션이 있으면 하위 클래스까지 상속이 가능합니다.</li>
    <li>@Target: 해당 애노테이션을 어디에 사용할 지 결정합니다. (타입, 필드, 메서드, 파라미터, 생성자, 로컬변수, 애노테이션 타입)</li>
  </ul>
</details>

<details>
  <summary>오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?</summary>
  </br>
  
  <p>오버라이딩은 상위 클래스의 메소드를 재정의 하는 것을 의미합니다. </p>
  <p>오버로딩은 같은 클래스 내에서 동일한 메소드 이름을 가지지만, 매개변수의 타입, 개수가 다르게 구현할 수 있는 것을 의미하며 컴파일 타임 다형성이기도 합니다. 따라서 오버라이딩 될 수 있습니다.</p>
  <p>추가로 `@Override`를 써야하는 이유를 꼭 생각해보세요. 이 애노테이션은 컴파일 타임에 오버라이딩에 대한 안정성을 부여해주기 때문에 반드시 써주는 것이 좋습니다.</p>
</details>

<details>
  <summary>인터페이스와 추상클래스의 차이점에 대해 설명해주세요.</summary>
  </br>
  <p>인터페이스는 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용합니다. 다중 상속이 가능합니다. 인터페이스를 구현하는 집합간에는 관계가 없을 수 있습니다.</p>
  <p>추상클래스는 공통된 개념을 표현할 때 사용합니다. 단일 상속만 가능합니다. 추상클래스를 상속하는 집합 간에는 연관관계가 있습니다.</p>
</details>

<details>
  <summary>클래스는 무엇이고 객체는 무엇인가요?</summary>
  </br>
  <p>클래스는 객체를 정의하는 틀 또는 설계도와 같은 의미로 사용됩니다.</p>
  <p>객체는 식별 가능한 개체 또는 사물입니다. 객체는 구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태를 가집니다. 인스턴스들을 통칭하는 용도로 사용합니다.</p>
</details>

<details>
  <summary>정적(static)이란 무엇인가요?</summary>
  </br>
  <p>static은 클래스 멤버라고 하며, 클래스 로더가 클래스를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리됩니다.</p>
  <p>static 키워드를 통해 생성된 정 적멤버들은 PermGen 또는 Metaspace에 저장되며 저장된 메모리는 모든 객체가 공유하며 하나의 멤버를 어디서든지 참조할 수 있는 장점이 있습니다.</p>
  <p>그러나, GC의 관리 영역 밖에 존재하기 때문에 프로그램 종료시까지 메모리가 할당된 채로 존재합니다. 너무 남발하게 되면 시스템 성능에 악영향을 줄 수 있습니다.</p>
</details>

<details>
  <summary>자바의 원시타입들은 무엇이 있으며 각각 몇 바이트를 차지하나요?</summary>
  </br>
  <p>boolean(1), char(unsigned 2), byte(1), short(2), int(4), long(8), float(4), double(8)</p>
  <p>사실 JVM에 의존적이기 때문에 정확한 크기라기 보다는 대략적인 크기입니다.</p>
</details>

<details>
  <summary>접근 제어자의 종류와 이에 대해 설명해주세요.</summary>
  </br>
  <p>private, default, protected, public이 있습니다. private은 해당 클래스 내에서만 접근 가능하고, default는 해당 패키지, protected는 상속한 클래스, public은 전체 영역에서 접근 가능합니다.</p>
  <p>접근 제어자를 사용하는 이유는 외부에 보여주고 싶은 정보들을 선택적으로 제공위해서 입니다.</p>
</details>

<details>
  <summary>객체지향에 대해서 설명해주세요.</summary>
  </br>
  <p>객체지향을 정의하면, 의존성 관리입니다.</p>
  <p>객체지향으로 의존성을 관리함으로써 변경 영향을 최소화하고 독립적인 배포가 가능해지며 독립적인 개발이 가능해집니다. 따라서 객체지향에서 가장 중요한 것은 DIP(Dependency Inversion Principle)를 통한 고수준 정책(High Level Policy)와 저수준 구현 세부사항(Low Level Details)의 분리라고 할 수 있습니다.</p>
</details>

<details>
  <summary>SOLID(객체지향 5대원칙)에 대해서 설명해주세요.</summary>
  </br>
  <p>SRP(단일책임원칙)은 한 클래스의 하나의 책임만 가져야 합니다.</p>
  <p>OCP(개방-폐쇄 원칙)은 확장에는 열려 있으나 변경에는 닫혀 있어야 하며, 다형성을 활용해야 합니다.</p>
  <p>LSP(리스코프 치환 원칙)은 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야하는 원칙으로 상위 타입을 상속해서 재정의 했을 때 프로그램이 깨지지 않아야 합니다.</p>
  <p>ISP(인터페이스 분리 원칙)은 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안되는 원칙입니다. 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 더 낫습니다. 즉, 비대한 인터페이스보단 더 작고 구체적인 인터페이스로 분리해야합니다.</p>
  <p>DIP(의존관계 역전 원칙)은 추상적인 것은 자신보다 구체적인 것에 의존하지 않고, 변화하기 쉬운 것에 의존해서는 안된다는 원칙입니다. 구체적으론 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 하는 원칙입니다.</p>ㅐ
</details>

<details>
  <summary>동일성(identity)와 동등성(equality)에 대해 설명해주세요. (equals(), ==)</summary>
  </br>
  <p>동일성은 객체의 주소를 비교하는 것이고, 동등성은 객체의 같음을 비교하는 것입니다.</p>
  <p>기본적으로 자바에서는 Object 클래스에 정의된 equals() 메소드가 동일성 비교를 합니다. 따라서, 개발자는 원한다면 equals() 메소드를 오버라이딩해서 동등성의 판단 기준을 정의해주면 됩니다.</p>
</details>

<details>
  <summary>원시타입과 참조타입의 차이에 대해 설명해주세요.</summary>
  </br>
  <p>원시타입은 Java에서 단 8개 밖에 존재하지 않는 타입입니다. 나머지는 모두 참조타입이라고 볼 수 있고, Object 클래스이거나 이를 상속하는 클래스들로 이루어져 있습니다.</p>
  <p>원시타입은 항상 값이 존재해야 합니다. 반면, Object 타입은 null 포인터를 가질 수 있습니다. 그리고 멤버변수가 초기화될 때, 원시타입은 기본값을 가지지만, 참조타입은 null 포인터를 가지는 차이도 있습니다.</p>
</details>

<details>
  <summary>String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.</summary>
  </br>
  <p>String은 불변입니다. StringBuilder와 StringBuffer는 이런 String의 특징을 보완하기 위해 사용하는 가변타입이라고 볼 수 있습니다.</p>
  <p>StringBuilder와 StringBuffer는 Thread-safe 여부의 차이가 있습니다. StringBuilder는 Thread-safe하지 않습니다. 따라서 Multi-Thread 환경에서 사용할 때는 StringBuffer를 사용합니다.</p>
</details>

<details>
  <summary>Checked Exception과 Unchecked Exception에 대해 설명해주세요. 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?</summary>
  </br>
  <p>둘의 차이는 RuntimeException을 상속하는가의 여부에 따라 다릅니다. RuntimeException을 상속하면 UncheckedException이 됩니다. 스프링 트랜잭션 추상화에서 rollback 대상은 바로 UncheckedException입니다.</p>
</details>

<details>
  <summary>Java8에서 추가된 기능에 대해서 설명해주세요.</summary>
  </br>
  <p>자신이 사용한 경험을 말해주면 더 효과적일 것 같습니다.</p>
  <p>Java8에서는 Lambda식, Stream API, Optional, 날짜 시간 API, StringJoiner 등이 추가되었습니다.</p>
  <p>lambda는 함수형 프로그래밍을 지원하기 위한 기능이고, Stream API는 고차함수를 지원합니다. Optional은 Null-safety를 제공하며, Stream과 사용법이 유사합니다. 날짜 시간 API는 Joda-time등의 라이브러리에서 영향을 받아 괜찮은 API가 되었으며, StringJoiner는 문자열을 간단하게 구분자로 합칠 수 있는 기능을 제공합니다.</p>
</details>

<details>
  <summary>강한 결합과 느슨한 결합이 무엇인지 설명해주세요.</summary>
  </br>
  <p>결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 정보를 알고 있는지에 대한 척도입니다.</p>
  <p>어떤 모듈이 다른 모듈에 자세한 부분(구현 세부사항)까지 알고 있을 경우에 강한 결합도를 가진다고 합니다.</p>
  <p>어떤 모듈이 다른 모듈에 대해 필요한 정보(인터페이스로 추상화된 고수준 정책)만 알고 있다면 두 모듈은 낮은 결합도를 가진다고 합니다.</p>
  <p>객체지향 관점에서 결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지를 나타냅니다. 이러한 관점에서 강한 결합도는 반드시 지양해야 하며, 개발자는 적절한 결합도를 유지할 수 있도록 고민하고 설계해야 합니다.</p>
</details>

<details>
  <summary>직렬화와 역직렬화에 대해서 설명해주세요.</summary>
  </br>
  <p>직렬화란 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 데이터 변환하는 기술과 바이트로 변환된 데이터를 다시 변환하는 기술(역직렬화)을 아울러서 이야기 합니다.</p>
  <p>자바 직렬화는 JVM의 메모리에서만 상주되어있는 객체 데이터를 영속화(Persistence)가 필요할 때 사용됩니다. 시스템이 종료되더라도 없어지지 않는 장점을 가지며 영속화된 데이터이기 때문에 네트워크로 전송이 가능합니다.</p>
</details>


<details>
  <summary>Mutable 객체와 Immutable 객체의 차이점에 대해 설명해주세요.</summary>
  </br>
  <p>Mutable 객체는 변경 가능 객체이고, Immutable 객체는 불변 객체라고 흔히들 말합니다.</p>
  <p>Mutable 객체는 도메인 개체(도메인 클래스 혹은 엔터티)로 사용됩니다. Mutable 객체의 변경 메서드는 Command method라고도 부르며, 리턴 타입을 void 로 정의합니다. 또한 void 리턴 타입의 어떠한 상태를 변경하는 메서드는 모두 Command method의 상징입니다.</p>
  <p>
  Immutable 객체는 불변객체이며 값 객체, 서비스 객체 등에 사용됩니다. Immutable 객체의 변경 메서드는 변경한 객체의 복사본을 반환해야 합니다.
  </p>
</details>

<details>
  <summary>자바에서 null을 안전하게 다루는 방법에 대해 설명해주세요.</summary>
  </br>
  <p>공개 메서드가 아닌 곳에는 assert를 사용하여 null을 방어할 수 있습니다. 또한 메서드의 인자를 받을 때 Objects.requireNonNull()을 사용하여 방어할 수 있습니다. 그리고 Optional을 사용해 리턴 타입에서 null을 반환하지 않도록 방어할 수 있습니다. 마지막으로 사전 조건과 사후 조건을 명확히 하여 계약에 의한 설계를 실천해야 합니다.</p>
</details>

#### Spring

<details>
  <summary>Spring DI/IoC는 어떻게 동작하나요?</summary>
  </br>
  <p>IoC(제어의 역전)은 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것으로 코드의 최종 호출은 개발자가 제어하는 것이 아닌 프레임워크의 내부에서 결정된 대로 이루어집니다.</p>
  <p>DI(의존관계 주입)은 Spring 프레임워크에서 지원하는 IoC의 형태로 클래스 사이의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결해줍니다.</p>
  <p>스프링에서는 스프링 컨테이너 ApplicationContext를 이용하여 설정 정보를 생성, 등록하고 필요한 객체를 생성자 혹은 setter를 통해 주입합니다.</p>
</details>

<details>
  <summary>Spring Bean이란 무엇인가요?</summary>
  </br>
  <p>IoC 컨테이너 안에 들어있는 객체로 필요할 때 IoC컨테이너에서 가져와서 사용합니다. @Bean 을 사용하거나 xml설정을 통해 일반 객체를 Bean으로 등록할 수 있습니다.</p>
</details>

<details>
  <summary>스프링 Bean의 생성 과정을 설명해주세요.</summary>
  </br>
  <p>객체 생성 → 의존 설정 → 초기화 → 사용 → 소멸 과정의 생명주기를 가지고 있습니다. Bean은 스프링 컨테이너에 의해 생명주기를 관리하며 빈 초기화방법은 @PostConstruct 를 빈 소멸에서는 @PreDestroy 를 사용합니다.</p>
  <p>생성한 스프링 빈을 등록할 때는 ComponentScan을 이용하거나 @Configuration 의 @Bean 을 사용하여 빈 설정파일에 직접 빈을 등록할 수 있습니다.</p>
</details>

<details>
  <summary>스프링 Bean의 Scope에 대해서 설명해주세요.</summary>
  </br>
  <p>빈 스코프는 빈이 존재할 수 있는 범위를 뜻하며 싱글톤, 프로토타입, request, session, application 등이 있습니다.</p>
  <p>싱글톤은 기본 스코프로 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프입니다.</p>
  <p>프로토타입은 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프입니다.</p>
  <p>request는 웹 요청이 들어오고 나갈때까지 유지하는 스코프, session은 웹 세션이 생성, 종료할때까지, application은 웹 서블릿 컨텍스트와 같은 범위로 유지하는 스코프입니다.</p>
</details>

<details>
  <summary>IoC 컨테이너의 역할은 무엇이 있을까요?</summary>
  </br>
  <p>애플리케이션 실행시점에 빈 오브젝트를 인스턴스화하고 DI 한 후에 최초로 애플리케이션을 기동할 빈 하나를 제공해줍니다.</p>
</details>

<details>
  <summary>DI 종류는 어떤것이 있고, 이들의 차이는 무엇인가요?</summary>
  </br>
  <p>DI는 세가지 방법이 있습니다. 생성자 삽입, Setter를 이용한 메소드 매개 변수 삽입, 필드 주입이 있습니다.</p>
  <p>생성자 주입은 생성자 호출시점에 딱 1번만 호출되는 것을 보장하며 불변, 필수 의존관계에 사용합니다.</p>
  <p>Setter주입은 선택, 변경 가능성이 있는 의존관계에 사용되며 스프링빈을 선택적으로 등록이 가능합니다.</p>
  <p>필드 주입은 `@Autowired` 를 사용하는데 외부에서 변경이 불가능하여 테스트 하기 힘듭니다. DI 프레임워크 없이는 작동하기 힘들며, 주로 애플리케이션과 관계없는 테스트코드나 `@Configuration` 같은 스프링 설정 목적으로 사용합니다. </p>
</details>

<details>
  <summary>Autowiring 과정에 대해서 설명해주세요.</summary>
  </br>
  <p>컨테이너에서 타입(인터페이스 또는 오브젝트)을 이용해 의존 대상 객체를 검색하고 할당할 수 있는 빈 객체를 찾아 주입한다</p>
</details>

<details>
  <summary>프론트 컨트롤러 패턴이란 무엇인가요?</summary>
  </br>
  <p>클라이언트의 다양한 요청마다 서블릿을 만들어서 사용한다고 하면 개발과 유지보수의 효율이 떨어질 수 밖에 없습니다. 프론트 컨트롤러 패턴을 사용함으로써 각 요청을 적절한 곳으로 위임해줌으로써 개발과 유지보수의 효율성이 증가하고 모든 요청에 대해 보안, 국제화, 라우팅 및 로그와 같은 일반적인 기능을 한 곳에서 캡슐화할 수 있습니다. Spring에서는 DispatcherServlet이 프론트 컨트롤러 패턴을 사용한 예이며, DispatcherServlet이 Bean으로 등록되어 package를 scan하고 @Controller, @RestController 애노테이션을 확인하여 어떠한 요청이 들어왔을 때 적절한 Handler Method에 위임해줍니다.</p>
</details>

<details>
  <summary>Servlet Filter와 Spring Interceptor의 차이는 무엇인가요?</summary>
  </br>
  <p>Filter는 Servlet Filter로써 javax.servlet 스펙에 포함되는 클래스입니다.</p>
  <p>Interceptor는 Spring MVC 스펙에 포함되어 있는 클래스입니다.</p>
  <p>Filter는 Servlet에서 전후처리를 담당하며, Interceptor는 Spring에서 Handler를 실행하기 전후나, ViewResolver를 통해 컨트롤러에서 리턴한 View Name으로부터 렌더링을 담당할 View 오브젝트를 준비해 돌려준 후 실제 View를 렌더링한 후에 어떠한 처리를 담당합니다.</p>
  <p>Filter는 Web Application(Tomcat을 사용할 경우 web.xml)에 등록하며, Interceptor는 Spring의 Application Context에 등록합니다.</p>
  <p>Filter는 Method Signature에 있는 Argument인 HttpServletRequest 혹은 HttpServeltResponse를 ServletRequest, ServletResponse 등으로 교체할 때 사용하거나, 데이터 변환(다운로드 파일의 압축 및 데이터 암호화 등), XSL/T를 이용한 XML 문서 변경, 사용자 인증, 자원 접근에 대한 로깅 등에 사용합니다.</p>
  <p>Interceptor의 경우 AOP를 흉내내거나, Spring 애플리케이션에서 전역적으로 전후처리 로직에서 예외를 사용하도록 하거나, Handler Method에서 사용자의 권한을 체크해서 다른 동작을 시켜준다거나 할 때 사용합니다.</p>
  <p></p>
</details>

<details>
  <summary>Spring에서 CORS 에러를 해결하기 위한 방법을 설명해주세요.</summary>
  </br>
  <p>Servlet Filter를 사용하여 커스텀한 Cors 설정하거나, WebMvcConfiguer를 구현한 Configuration 클래스를 만들어서 addCorsMappings()를 재정의할 수도 있고, 마지막으로 Spring Security에서 CorsConfigurationSource를 Bean으로 등록하고 config에 추가해줌으로써 해결할 수 있습니다.</p>
  <p>Controller 클래스에 @Crossorigin 어노테이션을 통해 해결할 수 있습니다.</p>
</details>

<details>
  <summary>Bean/Component 어노테이션에 대해서 설명해주시고, 둘의 차이점에 대해 설명해주세요.</summary>
  </br>
  <p>두 어노테이션 모두 IoC 컨테이너에 Bean을 등록하기 위해 사용합니다</p>
  <p>@Component : 개발자가 작성한 class를 기반으로 실행시점에 인스턴스 객체를 1회(싱글톤) 생성합니다</p>
  <p>@Controller, @Service, @Repository 는 모두 @Component 이며 실행시점에 자동으로 의존성을 주입합니다</p>
  <p>@Bean : 개발자가 작성한 method를 기반으로 메서드에서 반환하는 객체를 인스턴스 객체로 1회(싱글톤) 생성합니다</p>
</details>

<details>
  <summary>POJO란 무엇인가요? Spring Framework에서 POJO는 무엇이 될 수 있을까요?</summary>
  </br>
  <p>POJO는 프레임워크 인터페이스, 클래스를 구현하거나 확장하지 않은 단순한 클래스로 Java에서 제공하는 API 외에 종속되지 않습니다. 특정 환경에 종속되지 않아 코드가 간결하고 테스트 자동화에 유리합니다. 스프링에서는 도메인과 비즈니스 로직을 수행하는 대상이 POJO대상이 될 수 있습니다.</p>
</details>

<details>
  <summary>Spring Web MVC에서 요청 마다 Thread가 생성되어 Controller를 통해 요청을 수행할텐데, 어떻게 1개의 Controller만 생성될 수 있을까요?</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>Filter는 Servlet의 스펙이고, Interceptor는 Spring MVC의 스펙입니다. Spring Application에서 Filter와 Interceptor를 통해 예외를 처리할 경우 어떻게 해야 할까요?</summary>
  </br>
  <p>Filter는 DispatcherServlet 외부에 존재하기 때문에 예외가 발생했을 때 ErrorController에서 처리해야 합니다. 하지만 Interceptor는 DispatcherServlet 내부에 존재하기 때문에 @ControllerAdvice를 적용해서 처리할 수 있습니다.</p>
</details>

<details>
  <summary>Spring Application을 구동할 때 메서드를 실행시키는 방법에 대해 설명해주세요.</summary>
  </br>
  <p>CommandLineRunner, ApplicationRunner를 구현한 클래스를 만들어서 실행시키는 2가지 방법이 있습니다. 또한 Spring의 ApplicationEvent를 사용한 방법, @Postconstruct를 사용한 방법, InitializingBean 인터페이스를 구현하는 방법, @Bean의 initMethod를 사용한 방법이 있습니다.</p>
</details>

<details>
  <summary>의존성과 설정값을 생성자 인자로 주입해야 하는 이유에 대해 설명해주세요.</summary>
  </br>
  <p>모든 의존성을 생성자를 통해 주입하면, 인스턴스 생성 시 즉시 어떠한 동작을 실행할 수 있습니다. 또한 추가적인 설정은 필요하지 않으며, 뜻하지 않게 의존성과 설정값을 빠뜨리는 일이 발생하지 않고 테스트에도 용이합니다.</p>
</details>

#### JPA
<details>
  <summary>JPA 영속성 컨텍스트의 이점(5가지)을 설명해주세요.</summary>
  </br>
  <p>영속성 컨텍스트는 엔티티를 영구 저장하는 환경을 의미합니다.</p>
  <p>영속성 컨텍스트를 쓰는 이유는 1차 캐시, 동일성 보장, 쓰기 지연, 변경감지(Dirty checking), 지연로딩이 있습니다.</p>
  <ul>
    <li>1차 캐시: 조회가 가능하며 1차 캐시에 없으면 DB에서 조회하여 1차 캐시에 올려 놓습니다.</li>
    <li>동일성 보장: 동일성 비교가 가능합니다.(==)</li>
    <li>쓰기 지연: 트랜잭션을 지원하는 쓰기 지연이 가능하며 트랜잭션 커밋하기 전까지 SQL을 바로 보내지 않고 모아서 보낼 수 있습니다.</li>
    <li>변경 감지(Dirty checking): 스냅샷을 1차 캐시에 들어온 데이터를 찍습니다. commit 되는 시점에 Entity와 스냅샷과 비교하여 update SQL을 생성합니다.</li>
    <li>지연 로딩: 엔티티에서 해당 엔티티를 불러올 때 그 때 SQL을 날려 해당 데이터를 가져옵니다.</li>
  </ul>
</details>

<details>
  <summary>JPA Propagation 전파단계를 설명해주세요.</summary>
  </br>
  <p>대기업면접에서 나왔던 질문으로 트랜잭션 고립단계와 같이 질문할 가능성이 있습니다.</p>
  <p>JPA Propagation은 트랜잭션 동작 도중 다른 트랜잭션을 호출(실행)하는 상황에 선택할 수 있는 옵션입니다.</p>
  <p>@Transactional의 propagation 속성을 통해 피호출 트랜잭션의 입장에서는 호출한 쪽의 트랜잭션을 그대로 사용할 수도 있고, 새롭게 트랜잭션을 생성할 수도 있습니다.</p>
  <p>REQUIRED(디폴트): 부모 트랜잭션 내에서 실행하며 부모 트랜잭션이 없을 경우 새로운 트랜잭션을 생성합니다.</p>
  <p>이 외에도 종류가 REQUIRES_NEW, SUPPORTS, MANDATORY, NOT_SUPPORT, NEVER, NESTED 가 있지만 신입이 실제로 다뤄본 경험이 적기 때문에 REQUIRED(디폴트)값만 답변했습니다.</p>
</details>

<details>
  <summary>JPA를 쓴다면 그 이유에 대해서 설명해주세요.</summary>
  </br>
  <p>사실 면접관이 의도한 바를 파악하는게 중요합니다. 각기 다른 조건에서 같은 질문을 들었을 때 대답을 다르게 했던 기억이 납니다.</p>
  <p>제가 JPA를 사용하는 이유는 객체지향 프레임워크이기 때문입니다. JPA를 사용하면 비즈니스 로직이 RDBMS에 의존하는 것이 아니라, 자바 코드로 표현될 수 있기 때문입니다. 그로 인해서 생산성이 높아진다고 볼 수 있습니다.(이는 JPA에 익숙하다는 것을 전제로 합니다.)</p>
  <p>또, JPA는 JPQL로 SQL을 추상화하기 때문에 RDBMS Vendor에 관계없이 동일한 쿼리를 작성해서 같은 동작을 기대할 수 있다는 장점도 가지고 있습니다. 이는 database dialect를 지원하기 때문에 가지는 장점입니다.</p>
</details>

<details>
  <summary>N + 1 문제가 발생하는 이유와 이를 해결하는 방법을 설명해주세요.</summary>
  </br>
  <p>JPA와 관련된 단골문제입니다. 꼭 학습해둡시다.</p>
  <p>N + 1 쿼리는 JPA의 프록시로 인한 지연 로딩 때문에 발생합니다. 정확한 의미는 1개의 쿼리를 실행했을 때, 내부에 존재하는 컬렉션들을 조회해오면서 생기는 문제입니다. 기본적으로 되도록이면 @OneToMany의 매핑을 하지 않을 수 있다면 하지 않는 것이 최고의 예방책입니다.</p>
  <p>만약 그런 객체를 가져와야 하는 경우 Fetch Join이라고 하는 JPQL의 join fetch를 사용합니다. 쿼리 한 번으로 해결할 수 있고, 또 다른 방법으로는 EntityGraph를 사용하는 방법이 있습니다.</p>
</details>

### Python

<details>
  <summary>List와 Tuple의 차이에 대해 설명해주세요.</summary>
  </br>
  <p>- list는 가변적이며 tuple은 수정이 불가능하지만 속도가 더 빠릅니다.</p>
</details>

<details>
  <summary>파이썬 데코레이터에 대해 아는대로 설명해주세요.</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>Magic Method에 대해 설명해주세요.</summary>
  </br>
  <p>파이썬 객체 내부적으로 구현된(built-in) 메소드를 구현하는 것입니다.</p>
</details>

<details>
  <summary>__new__와 __init__의 차이에 대해 설명해주세요.</summary>
  </br>
  <p>__init__ : 클래스 인스터스 형태인 객체(Object)가 생성(Created/Instantiated)되어 초기화(Initialized)되는 즉시 호출(Called)되기는 하지만, 객체에 메모리를 할당하지 않는특수한 메소드라는 것입니다.</p>
  <p>__new__: init 전에 먼저 실행되어 새로운 인스턴스를 만들때 가장 먼저 호출된다. 클래스를 받아 실제로 인스턴스를 생성하고 __init__에게 인자들을 넘겨줍니다.</p>
</details>

<details>
  <summary>__repr__와 __str__의 차이에 대해 설명해주세요.</summary>
  </br>
  <p>__repr__: 인스턴스를 repr() 으로 호출할 때 호출되며, 기계가 읽기 쉬운 문자열을 출력하는 것을 목표로 합니다.</p>
  <p>str: 인스턴스를 str() 으로 호출할 때 호출되며, 사용자에게 읽기 쉬운 문자열을 출력하는 것을 목표로 합니다.</p>
</details>

<details>
  <summary>array와 list의 차이에 대해 설명해주세요.</summary>
  </br>
  <p>array : 요소의 data type이 동일해야 함 (import array)</p>
  <p>list : 요소의 data type 상관 없음</p>
</details>

<details>
  <summary>iterators와 generator 의 차이에 대해 설명해주세요.</summary>
  </br>
  <p>iterators: collection이나 문자열 하나씩 데이터 처리할 수 있는 iterable 객체의 iterator를 return</p>
  <p>generator : iterator의 특수 함수 형태로 함수 내 yield를 통해 데이터 하나씩 return</p>
</details>

<details>
  <summary>Call by --에 대해 설명해주세요.</summary>
  </br>
  <p> Call by value : 인자로 받은 값을 복사하여 처리하는 방식으로 Call By Value에 의해 넘어온 값을 증가시켜도 원래의 값이 보존됩니다. 하지만 값을 복사하여 넘기기 때문에 메모리 사용량이 늘어납니다. </p>
  <p>Call by reference : 인자로 받은 값의 주소값을 참조하는 방식으로 값을 복사하지 않고 직접 참조하기 때문에 속도가 빠릅니다. 하지만 원래의 값에 영향을 준다는 위험성이 존재합니다.</p>
  <p>Call by object : Python 내에서는 모든 것을 객체로 보고 immutable object(int, float, str, tuple)은 call by value로 동작 / mutable object(list, dict, set)은 call by reference로 동작</p>
</details>

<details>
  <summary>[ 프레임워크와 라이브러리 차이 ]</summary>
  </br>
  <p>라이브러리: 사용자가 흐름에 대한 제어를 하며 필요한 상황에 가져다가 쓸 수 있습니다.</p>
  <p>프레임워크: 전체적인 흐름을 자체적으로 제어합니다.</p>
  <p>프레임워크와 라이브러리는 실행 흐름에 대한 제어 권한이 어디 있는지에 따라 달라집니다. 프레임워크를 사용하면 사용자가 관리해야 하는 부분을 프레임워크에 넘김으로써 신경써야 할 것을 줄이는 IoC가 적용됩니다.</p>
</details>

<details>
  <summary>[ 동기와 비동기의 차이 ]</summary>
    </br>
    <p>동기(Synchronous) 방식:요청을 보내고 실행이 끝나면 다음 동작을 처리하는 방식으로  순서에 맞추어 진행되기 때문에 제어하기 쉽습니다. 하지만 여러가지 요청을 동시에 처리할 수 없어 효율이 떨어집니다. </p>
    <p>비동기(Asynchronous) 방식: 요청을 보내고 해당 동작의 처리 여부와 상관없이 다음 요청이 동작하는 방식으로 작업이 완료되는 시간을 기다릴 필요가 없기 때문에 자원을 효율적으로 사용할 수 있습니다. 하지만 작업이 완료된 결과를 제어하기 어렵습니다.</p>
</details>

<details>
  <summary>global과 nonlocal 키워드의 차이에 대해 설명해주세요.</summary>
  </br>
  <p>Global Variables : 모든 global 영역에서 접근 가능한 변수</p>
  <p>Local Variables : function 안에서 정의되는 변수</p>
</details>
 
<details>
  <summary>classmethod와 staticmethod의 차이에 대해 설명해주세요.</summary>
  </br>
  <p>@staticmethod 인 경우에는 부모 클래스의 속성 값을 가져오지만, @classmethod 의 경우 cls 인자를 활용하여 클래스의 클래스 속성을 가져옵니다.</p>
</details>
 
## 기타

### 트러블 슈팅

<details>
  <summary>대용량 트래픽에서 장애가 발생하면 어떻게 대응할 것인가요?</summary>
  </br>
  <p>캐쉬에서 트래픽이 감당이 안되거나 오류가 나면 DB에서 조회하게끔 서킷브레이커를 걸어서 다른 방법으로 우회하도록 제공할 것입니다.</p>
</details>

### 디자인 패턴
- 디자인패턴이라 여러 프로그래머들의 경험과 지혜를 모아서 공통적인 소프트웨어 디자인 문제를 해결하는데 도움이 될수 있게 만들어 놓은 것 입니다.

<details>
  <summary>싱글톤 패턴에 대해서 설명해주세요.(생각보다 어려움)</summary>
  </br>
  <p>전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴입니다.</p>
  <p>하나의 인스턴스만을 생성하며 getInstance메서드로 모든 클라이언트에게 동일한 인스턴스를 반환합니다.</p>
  <p>private 생성자를 가지는 특징을 가지며, 생성된 싱글톤 오브젝트는 저장할 수 있는 자신과 같은 타입의 스태틱 필드를 정의합니다.</p>
  <p>싱글톤 패턴의 문제점은 다음과 같습니다.</p>
  <ul>
    <li>의존 관계상 클라이언트가 구체 클래스에 의존합니다.</li>
    <li>private 생성자 때문에 테스트가 어렵습니다.</li>
    <li>객체 인스턴스를 하나만 생성해서 공유하는 방식 때문에 싱글톤 객체를 stateful하게 설계 했을 경우 큰 장애 발생요인이 됩니다.</li>
  </ul>
  <p>싱글톤의 단점을 해결하기 위해 무상태(stateless)로 설계해야 합니다.</p>
  <ul>
    <li>특정 클라이언트에 의존적인 필드가 있으면 안됩니다.</li>
    <li>특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안됩니다.</li>
    <li>가급적 읽기 전용으로 만들고, 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용합니다.</li>
  </ul>
</details>

<details>
  <summary>가교 패턴(브릿지 패턴)에 대해서 설명해주세요.</summary>
  </br>
  <p>가교 패턴은 추상부와 구현부를 분리하는 디자인 패턴입니다. 해당 패턴에서 기능은 인터페이스를 통해 정의 및 이용되고 해당 인터페이스를 따르는 클래스를 통해 구현됩니다. 해당 패턴을 통해서 사용자는 추상부와 구현부를 독립적으로 수정 및 확장할 수 있습니다. 가교 패턴은 객체지향 설계의 SOLID 원칙 중 단일 책임 원칙(SRP)과 개방 폐쇄 원칙(OCP)에 부합한 패턴입니다.</p>
</details>

<details>
  <summary>전략 패턴에 대해서 설명해주세요.</summary>
  </br>
  <p>전략 패턴은 알고리즘을 객체 단위로 캡슐화하는 디자인 패턴입니다. 해당 패턴에서 알고리즘은 인터페이스를 통해 정의 및 이용되고 해당 인터페이스를 따르는 클래스를 통해 구현됩니다. 해당 패턴을 통해서 사용자는 알고리즘을 필요에 따라 바꿔서 사용할 수 있게 됩니다. 전략 패턴은 객체지향 설계의 SOLID 원칙 중 개방 폐쇄 원칙(OCP)에 부합한 패턴입니다.</p>
  <p>전략 패턴은 가교 패턴과 구조가 비슷하지만 목적에 차이가 있습니다. 가교 패턴이 추상과 구현의 분리를 통한 독립적 개발의 용이성에 중점을 둔다면 전략 패턴은 알고리즘의 캡슐화를 통한 알고리즘 변경의 유연성에 중점을 둡니다.</p>
</details>

<details>
  <summary>빌더 패턴에 대해서 설명해주세요.</summary>
  </br>
  <p>복잡한 객체를 생성하는 클래스와 표현하는 클래스를 분리하여, 동일한 절차에서도 서로 다른 표현을 생성하는 방법을 제공한다.</p>
</details>

<details>
  <summary>팩토리 메서드 패턴에 대해서 설명해주세요.</summary>
  </br>
  <p>객체를 만드는 부분을 Sub class에 맡기는 패턴입니다.</p>
</details>

<details>
  <summary>퍼사드 패턴에 대한 예를 들어주세요.</summary>
  </br>
  <p>바운디드 컨텍스트로 구분된 각각의 독립적인 애플리케이션을 UI 서버를 통해 파사드 역할을 담당하도록 두고 각 바운디드 컨텍스트에서 UI 서버와 통신하기 위해 HTTP, Protobuf, Thrift와 같은 방식을 이용할 수 있습니다.</p>
</details>

### 테스트

<details>
  <summary>테스트 코드에 대해서 어떻게 생각하고, 작성하나요?</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>TDD를 알고 있나요? TDD에 대해서 어떻게 생각하나요?</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>테스트 커버리지에 대해서 어떻게 생각하나요?</summary>
  </br>
  <p>라인 커버리지, 브랜치 커버리지를 높은 수치로 달성하는 것은 바람직하지 않다고 생각합니다. 핵심 비즈니스 로직의 패스 커버리지를 갖는 것이 라인 커버리지, 브랜치 커버리지를 높은 수치로 유지하는 것보다 낫다고 생각합니다. 또한 무의미한 테스트 코드를 작성함으로써 유지보수 비용을 발생시키거나 읽기 좋은 코드를 테스트 커버리지를 채우기 위해 수정하는 등의 일은 반드시 피해야 한다고 생각합니다.</p>
</details>

### 인프라/클라우드

<details>
  <summary>로드 밸런서에 대해서 설명해주세요.</summary>
  </br>
  <p>둘 이상의 CPU or 저장장치와 같은 컴퓨터 자원들에게 작업을 나누는 것을 의미합니다.</p>
</details>

<details>
  <summary>리버스 프록시에 대해서 설명해주세요.</summary>
  </br>
  <p>클라이언트로부터의 요청을 받아서(필요하다면 주위에서 처리한 후) 적절한 웹 서버로 요청을 전송합니다. 웹 서버는 요청을 받아서 평소처럼 처리를 하지만, 응답은 클라이언트로 보내지 않고 Reverse Proxy로 반환하고 요청을 받은 Reverse Proxy는 그 응답을 클라이언트로 반환하는 것을 말합니다..</p>
</details>

<details>
  <summary>Fault-tolerant(무정지) 시스템으로 가기 위해 필요한 방법에 대한 생각을 말해주세요. </summary>
  </br>
  <p>다운 타임이 발생하지 않도록 두 대 이상의 서버를 서비스해야 하고 비용 절감을 위해 배포할 때에만 새롭게 서비스를 띄우고, 배포가 완료된 후에는 기존 서버는 셧다운 시키면 됩니다.</p>
  <p>무정지 배포 방법 Rolling </br>
  로드 밸런서에서 서버를 빼고, 배포하고 다시 넣는 작업이 각 서버마다 이루어지도록 합니다. </br>
  Rolling 배포의 단점은 배포할 서버가 너무 많다면, n대 단위로 배포하기도 하는데 배포가 모두 끝나기 전까지 클라이언트 중 누구는 이전 서비스를 제공 받고 누구는 신규 서비스를 제공 받게 되는 문제가 발생합니다. 또한 1대에 배포하는 것보다 최소 2배 이상 느립니다.
  </p>
  <p>무정지 배포 방법 Canary </br>
  소수의 유저(혹은 사내)만 사용하는 환경(Canary 환경)에 신규 버전을 배포하고 문제가 없다고 판단됐을 때 다른 모든 서버에 배포합니다.
  </p>
  <p>무정지 배포 방법 Blue/Green </br>
  실제로 서비스 중인 환경(Blue)과 새롭게 배포할 환경(Green)을 세트로 준비해서 배포하는 형식입니다. </br>
  새롭게 배포할 환경에만 배포하면 되기 때문에 배포 속도가 매우 빠르며, 언제나 Green 환경이 실행 중이기 때문에 만약 잘못된 버전으로 배포 했을 경우 신속하게 롤백이 가능합니다. </br>
  Blue/Green 배포의 단점은 Green 환경이 항상 실행 중이어야 하기 때문에 비용이 많이 발생합니다.
  </p>
</details>

### 컨테이너

<details>
  <summary>클라우드</summary>
  </br>
  <p>물리적인 서버가 없이도 인터넷에 접속하여 다양한 자원을 사용할 수 있게 하는 컴퓨터 리소스 이용형태를 말합니다. </p>
</details>

<details>
  <summary>물리서버와 클라우드 서버의 특징?</summary>
  </br>
  <p>물리서버의 경우 일반적으로 기업이나 사용자가 서버를 소유하고 있습니다.
하지만 클라우드 서버는 모든 리소스를 클라우드 서비스 업체에서 소유하고, 해당 리소스를 서비스로 만든것을 사용자가 사용하는 형태입니다.</p>
</details>

<details>
  <summary>Docker란 무엇이고 컨테이너 가상화를 왜 사용할까요?</summary>
  </br>
  <p>도커는 컨테이너 기반의 오픈소스 가상화 플랫폼입니다. </p>
  <p>컨테이너와 가상머신 비교
가상머신으로 사용한다면 구성 요소 프로세스뿐만 아니라 시스템 프로세스를 실행해야 하기 때문에 추가 컴퓨팅 리소스가 필요합니다. 하지만 컨테이너는 호스트 OS에서 실행되는 하나의 격리된 프로세스이기 때문에 애플리케이션이 소비하는 리소스만 소비하고 추가 프로세스의 오버헤드는 없습니다. </p>
</details>

<details>
  <summary>Public Cloud와 Private Cloud가 어떤 차이점이 있는지 설명하시오.</summary>
  </br>
  <p>퍼블릭 클라우드는 최종 사용자가 소유하지 않은 IT 인프라에서 생성되는 클라우드 환경입니다. 가장 대표적인 퍼블릭 클라우드 제공업체로는 AWS(Amazon Web Services), Google Cloud, IBM Cloud, Microsoft Azure 등이 있습니다.</p>
  <p>프라이빗 클라우드는 단일 최종 사용자 또는 그룹의 전용 클라우드 환경으로, 실행 시 해당 사용자 또는 그룹의 방화벽으로 보호됩니다. 완전히 독립적인 액세스 권한이 있는 사용자만이 IT 인프라를 독점적으로 사용할 수 있습니다. </p>
</details>

### DevOps

DevOps는 어쩌면 신입에겐 물어보지 않을 수도 있습니다. 하지만 DevOps가 무엇인지 정도는 알아두는게 좋을 것 같습니다.

<details>
  <summary>CI/CD가 무엇인가요? 왜 CI/CD가 장점이 될까요?</summary>
  </br>
  <p>보통 이 질문을 하는 동시에 어떤 CI/CD를 써봤는지 질문을 할 것입니다. 그때 썼던 CI/CD툴을 설명하고, 그 툴의 장단점을 설명하면 좋습니다.</p>
  <p>코드 버전 관리를 하는 VCS 시스템에 push가 되면 테스트와 빌드가 수행되어 안정적인 배포파일을 만드는 과정을 CI(지속적 통합, continuous integration)이라고 하며, 이 빌드 결과를 자동으로 운영 서버에 배포까지 되는 과정을 CD(지속적 배포, continuous delivery or continuous deployment)라고 합니다.</p>
  <p>푸시가 될 때마다 코드를 병합하고, 테스트 코드와 빌드를 수행하면서 자동으로 코드가 통합되어 더는 수동으로 코드를 통합할 필요가 없어져 개발에만 신경을 쓸 수 있습니다.</p>
  <p>이 CI / CD의 중요한 것은 테스트 자동화입니다. 프로젝트의 완전한 상태임을 보장하기 위해 테스트 코드가 구현되어 있어야 합니다.</p>
</details>

<details>
  <summary>DevOps가 무엇인지 설명해주세요.</summary>
  </br>
  <p>DevOps는 애플리케이션과 서비스를 빠른 속도로 제공할 수 있도록 조직의 역량을 향상시키는 문화와 방식이며 자동화, 측정, 공유를 수행하고 이 모든 것들을 축적해나가는 것입니다.</p>
  <p>DevOps를 수행하면, 기존의 개발 및 인프라 관리 프로세스를 사용하는 조직보다 제품을 더 빠르게 혁신하고 개선할 수 있습니다. 이를 통해서 고객 친화적이고, 시장에 효과적으로 대응할 수 있는 유연성을 얻을 수 있습니다.</p>
</details>

### 커뮤니케이션

정답이 없는 질문입니다. 면접관마다 의도하는 답이 다 다를테니 자신만의 방법을 한 번 쯤 생각해보고 답변에 막힘이 없도록 준비합시다.

<details>
  <summary>어떤 기술이나 방법론이 좋아보일 때, 이를 어떻게 설득할 것인가요?</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>일정이 예상보다 지연될 것 같습니다. 어떻게 해결하실 것인가요?</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>팀원과의 갈등이 있었나요? 있었다면 어떻게 대처했나요?</summary>
  </br>
  <p></p>
</details>

### 개인의 역량

<details>
  <summary>본인이 수행한 프로젝트 중 상용화 가능한 프로젝트가 있나요?</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>기술을 습득할 때 어떤 식으로 습득하나요?</summary>
  </br>
  <p></p>
</details>

### 최신기술에 관심이 있는지

최신기술에 관심이 있는지 정도를 확인하고자 함입니다. 너무 정확하게 말하지 않아도 관심이 있다는 인상정도를 줄 수 있다면 좋겠습니다.  
그 회사의 기술 스택을 찾아보고 관심을 가져봤다 정도의 느낌을 줄 수 있어야합니다.  
사용까지 해보면 더더욱 좋을 것 같습니다.

<details>
  <summary>protobuf에 대해서 알고계신가요? 이것은 왜 사용할까요?</summary>
  </br>
  <p>JSON이 가진 문제점을 보완하기 위한 하기위한 직렬화 방법</p>
  <p>JSON은 문자열 형식이기 때문에 바이트를 많이 사용한다. 하지만 프로토버프는 속성값을 숫자로 대체해서 바이트 스트림으로 만들기 때문에 훨씬 용량을 적게 소모한다.</p>
  <p>장점으로는 데이터 크기가 작아 데이터 통신이 빠르다. 또한 파싱을 할 필요가 없다.</p>
  <p>단점으로는 사람이 읽기 어렵고, 학습비용이 조금 있다.(proto의 문법을 알아야 한다.)</p>
</details>

<details>
  <summary>gRPC는 무엇이며, RPC는 무엇인가요? 왜 쓸까요?</summary>
  </br>
  <p>gRPC는 HTML/JSON 방식의 비효율성을 개선하기 위해 나온 것입니다.</p>
  <p>RPC는 원격에 있는 프로시져(함수)를 로컬에 있는 것처럼 호출할 수 있도록 해주는 기술로 학습비용이 있기에 잘 사용되지 않았습니다.</p>
  <p>최근의 아키텍쳐 트렌드는 MSA를 기반으로 한 분산시스템으로 구성됩니다. MSA는 결국 각 서비스의 API를 호출하는 식으로 네트워크 통신을 하게 되는데, HTML/JSON보다는 gRPC/protobuf가 더 빠른 속도를 보이게 됩니다. 그로인해 서비스의 응답속도도 빨라질 수 있게됩니다.</p>
</details>

<details>
  <summary>쿠버네티스가 무엇인가요? 왜 쿠버네티스를 쓸까요?</summary>
  </br>
  <p> 쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성이 있고, 확장가능한 오픈소스 플랫폼입니다. 쿠버네티스를 사용하면 서비스 효율로 서버가 적어지기 때문에 유지보수 비용이 적게 드며 애플리케이션 배포의 단순화를 시킬 수 있고, 지속적으로 상태를 확인하기 때문에 장애가 발생할 경우 셀프 힐링이 가능합니다. + 오토 스케일링  </p>
</details>

## 백앤드 후기
- 테스트 코드를 짜면 좋은 점
- 테스트 코드를 짤 때 어떤 부분을 생각하면서 짜는지
- Cleancode란?
- CS
    - HTTP 프로토콜이란?
        - 'Hyper Text Transfer Protocol`의 줄임말로 연결상태를 유지하지 않는 비연결성 프로토콜입니다.
    - MVC 패턴 
        - Model, View, Controller의 약자로 애플리케이션을 세 가지의 역할로 구분한 소프트웨어 디자인패턴입니다.
        - Model: 데이터를 저장하는 컴포넌트
        - View: 사용자 인터페이스(UI) 컴포넌트
        - Controller: 사용자의 요청을 처리하고 Model과 View를 중개하는 컴포넌트
    - React와 Vue의 차이점은?
        - Javascript 기반의 Frontend Framework로 가상 DOM을 활용하며 반응적인고 조합 가능한 컴포넌트를 제공한다는 공통점을 가집니다.
        - 차이점은 ---
    - Java에서 람다 함수란?
        - 식별자 없이 실행 가능한 함수 표현식으로 Funcrional Language 함수형 프로그래밍에서 온 개념으로 매개변수를 가진 코드 블록이지만, 런타임 시에 익명 구현 객체를 생성합니다.
        - 목적 : 인터페이스가 가지고 있는 메소드를 간편하게 즉흥적으로 구현해서 사용하는 것이 목적입니다.
    - JVM에서 가비지 컬렉터가 어떻게 작동하는가?
        - 
    - SDLC란
        - 소프트웨어 개발 수명주기를 나타냅니다. 소프트웨어 개발을 위한 접근 방식을 정의하는데 이것에는 요구 사항 수집, 시스템 분석, 설계, 코딩, 테스트, 유지 관리 및 문서화와 같은 단계가 포함됩니다.
        - 단계: 요구 사항 분석, 디자인, 코딩, 테스팅, 유지 입니다.
    - SDLC에서 사용할 수 있는 다양한 모델은 무엇
        - 소프트웨어 개발을 효율적으로 수행하기 위해 SDLC에서 사용할 수 있는 모델을 여러가지가 있는데 폭포 모델, V-모델, 그리고 애자일 모델 등이 있습니다.
    - 기준선이라는 용어를 설명하십시오
        - 기준선이란 일반적으로 프로젝트 관리가 정의하는 프로젝트의 이정표입니다. 프로젝트의 전반적인 건전성을 평가하기 위해 수시로 프로젝트으 진행 상황을 추적하는데 기준선이 사용됩니다.
    - 소프트웨어 프로젝트 관리자의 책임은 무엇입니까?
        - 소프트웨어 프로젝트 관리자는 프로젝트를 성공적으로 완료 할 책임이 있습니다. 전체 팀이 소프트웨어 개발에 대해 체계적이고 잘 정의 된 접근 방식을 따르도록하는 것은 관리자의 책임입니다.
    - 응집력?
        - 모듈의 요소가 서로 상황 관련되는 정도입니다. 모듈의 요소를 함께 묶는 내부 접착제와 같습니다. 좋은 소프트웨어는 높은 수준의 응집력을 가지고 있습니다.
    - 커플 링?
        - 모듈 간의 상호 의존 정도입니다. 좋은 소프트웨어는 결합 수준이 낮습니다.
    - 모듈화?
        - 소프트웨어를 여러 구성요소 또는 모듈로 분할하는 데 사용됩니다. 각 모듈은 독립적인 개발 및 테스트 팀에서 작업합니다. 최종 결과는 여러 모듈을 단일 작업 구성 요소로 결합하는 것입니다.
    - 소프트웨어 구성 관리란?
        - 소프트웨어 개발 수명주기 동안 발생하는 변경 사항을 추적하고 제어하는 프로세스입니다 소프트웨어 개발 중에 이루어진 모든 변경 사항은 잘 정의되고 통제 된 프로세스를 통해 추적되어야 합니다.
    - CASE 도구란?
        - 소프트웨어 개발 수명주기의 다양한 활동을 지원하고 가속화하는 데 사용되는도구를 나타냅니다.
    - 블랙 박스 테스트란?
        - 내부 구조 또는 코드 구현에 대해 지식없이 애플리케이션 테스트가 포함됩니다. 테스터는 백앤드에서 데이터 흐름과 코드 실행보다는 블랙 박스 테스트에서 소프트웨어의 기능에만 신경썼습니다.
    - 화이트 박스 테스트란?
        - 내부 구조 및 코드 구현에 대한 지식으로 애플리케이션을 테스트하는 것입니다. 이 테스트는 일반적으로 단위 테스트의 형태로 코드를 작성한 개발자가 수행합니다.
    - 타당성 조사란?
        - 소프트웨어 제품 개발이 조직에 얼마나 실용적이고 유익한지 평가하기 위해 소프트웨어 제품에 대해 수행됩니다. 소프트웨어는 개발 될 소프트 웨어 제품의 경제적, 기술적 측면을 이해하기 위해 철저하게 분석됩니다.
    - 프로젝트 실행은 어떻게 측정할 수 있습니까?
        - 상태 보고서, 마일스톤 체크리스트, 활동 모니터링을 사용하여 프로젝트 실행 상태를 모니터링 할 수 있습니다.
    - 기능적 요구 상항은 무엇입니까?
        - 개발 된 소프트웨어 제품이 수행 할 것으로 예상되는 기능입니다.
    - 비 기능적 요구 사항?
        - 사용자 인터페이스 모양과 느낌, 보안, 성능, 상호 운영성, 안정성 등과 같은 응용 프로그램의 유용성을 측정합니다.
    - 품질 보증과 품질 관리의 차이점
        - 품질 보증은 제공된 소프트웨어에 가능한 최소한의 결함이 있는지 확인합니다. 품질 관리는 제품의 품질이 장기적으로 유지되도록하는 프로세스입니다.
        - 품질 보증은 프로젝트의 테스트 팀에서 수행하는 반면 품질 관리는 일반적으로 제품이 소프트웨어 엔지니어링의 유지 관리 단계에 있더라도 제품의 품질을 담당하는 전담 지원티멩서 수행합니다.   
    - 검증과 유효성 검증의 차이점
        - 검증은 프로세스 및 표준 관점에서 제품이 올바르게 구축되었는지 확인하는 프로세스 입니다.
        - 유효성 검사는 고객 관점에서 올바른 제품을 구축하도록 보장하는 프로세스입니다. 검증은 코드를 실행하지 않고 제품을 테스트하는 정적 테스트 방법론인 반면 검증은 동적 테스트 방법론입니다.
    - 소프트 웨어 제품에 가장 적합한 SDLC 모델은 무엇입니까?
        - 소프트웨어 제품에 사용해야 하는 특정 SDLC 모델을 지정하는 것과 같은 규칙은 없기 때문에 구축 중인 소프트웨어 프로젝트의 유형과 조직의 정책 및 절차에 따라 다릅니다.
    - 소프트웨어 범위란 무엇?
        - 소프트웨어 범위는 개발 된 소프트웨어에서 제공하는 기능 목록입니다. 소프트웨어의 범위를 기반으로 시간 할당, 예산 및 자원 할당과 같은 추정을 할 수 있습니다.
    - SRS란?
        - SRS는 Software requirement specification 문서로 제품의 모든 기능 및 비 기능적 요구 사항을 캡쳐하는 문서입니다.
    - 폭포 모델?
        - 첫 번째 단계가 완료된 후에만 다음 단계가 시작되는 순차모델입니다. 
    - V 모델
        - 검증 및 검증 모델을 나타냅니다. V 모델은 각 개발 단계는 해당 테스트 단계와 연관됩니다.


## 면접 꿀팁

회사의 기술스택에 관심을 가져보세요. 학습능력이 좋음을 어떤식으로 보여줄 수 있을까요?

본인이 수행한 프로젝트를 유의미한 트래픽이 나올정도로 해본 경험을 높게 평가하는 회사가 많습니다.

두괄식으로 답변하도록 합시다. (사실 힘듭니다. 그렇게 될 수 있게끔 연습 또 연습!)

프로젝트를 수행할 때, 내가 이 기술을 단순히 좋아보여서 사용한 것이 아니라, 많은 고민을 했음을 보여주도록 하세요. 가장 간단한 질문으로는 '왜 그 기술을 사용했나요?', '그 기술 말고 다른 기술은 왜 사용하지 않았나요?', '대체할만한 기술이 있나요?' 등이 있습니다.

[면접 꿀팁 영상!](https://youtu.be/4XNJFAPnZrY)


<!--
<details>
<summary></summary>
</br>
<p></p>
</details>
-->
